#ifndef VSCODE_ONLY
	#hdr
		#define CL_TARGET_OPENCL_VERSION 300
		#include <cstdint>
		#include "./Test.hpp"
		#include "./kernels.cl.hpp"
	#end
	#src
		#include <iostream>
		#include "./MyOpenCL.hpp"
		#include "./Util.hpp"
	#end
#else // if VSCODE
	#define CL_TARGET_OPENCL_VERSION 300
	#include <cstdint>
	#include "./Test.hpp"
	#include "./kernels.cl.hpp"
	#include <iostream>
	#include "./MyOpenCL.hpp"
	#include "./Util.hpp"
	#include "./KernelsTest.hpp"
#endif

#define PRINT_ARRAY_10(arr) "["\
	<< ((arr)[0]) << ", " \
	<< ((arr)[1]) << ", " \
	<< ((arr)[2]) << ", " \
	<< ((arr)[3]) << ", " \
	<< ((arr)[4]) << ", " \
	<< ((arr)[5]) << ", " \
	<< ((arr)[6]) << ", " \
	<< ((arr)[7]) << ", " \
	<< ((arr)[8]) << ", " \
	<< ((arr)[9]) << ", " \
<< "]"

namespace BJpeg {
	namespace {
		class KernelsTest : Test {
			virtual bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) = 0;
			virtual bool test() {
				cl_device_id device_id;
				if (!MyOpenCL :: getDeviceId(device_id)) { return false; }
				
				Resource<MyOpenCL :: Context> context(device_id);               if (!context) { return false; }
				Resource<MyOpenCL :: Queue>   queue(device_id, context);        if (!queue  ) { return false; }
				Resource<MyOpenCL :: Program> program(device_id, context, BJpeg::kernels); if (!program) { return false; }
				
				return self.kernelTest(context, queue, program);
			}
		};
		
		class TestInitializeBufferU32 : KernelsTest {
			const char *getDescription() { return "Test initializeBufferU32"; }
			bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource<MyOpenCL :: Kernel> kernel(program, "initializeBufferU32"); if (!kernel) { return false; }
				
				size_t amount = 1024;
				uint32_t value1 = 42;
				
				Resource<MyOpenCL :: Buffer<uint32_t>> device_buffer(context, CL_MEM_READ_WRITE, amount); if (!device_buffer) { return false; }
				
				if (!kernel.setArg(device_buffer.buffer)) { return false; }
				if (!kernel.setArg(value1, 1)) { return false; }
				if (!kernel(queue, 1, &amount)) { return false; }
				
				uint32_t value2 = 33;
				if (!kernel.setArg(value2, 1)) { return false; }
				size_t offset2 = 1;
				size_t amount2 = 2;
				if (!kernel(queue, 1, &amount2, &offset2)) { return false; }
				
				uint32_t my_buffer[10];
				
				if (!device_buffer.read(queue, my_buffer, 10)) { return false; }
				if (my_buffer[0] != value1) { std :: cerr << "Buffer wrong at 0: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[1] != value2) { std :: cerr << "Buffer wrong at 1: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[2] != value2) { std :: cerr << "Buffer wrong at 2: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[3] != value1) { std :: cerr << "Buffer wrong at 3: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[4] != value1) { std :: cerr << "Buffer wrong at 4: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[5] != value1) { std :: cerr << "Buffer wrong at 5: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[6] != value1) { std :: cerr << "Buffer wrong at 6: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[7] != value1) { std :: cerr << "Buffer wrong at 7: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[8] != value1) { std :: cerr << "Buffer wrong at 8: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[9] != value1) { std :: cerr << "Buffer wrong at 9: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				
				return true;
			}
		};
		TestInitializeBufferU32 test;
		
		void checkError(cl_int error, const char *message) {
			if (error != CL_SUCCESS) {
				printf("Error %d: %s\n", error, message);
				exit(1);
			}
		}
		
		
	}
}

// Error checking helper

// Main function to call the kernel

// Example usage:
/*
    // Assuming you have initialized OpenCL context, queue, and compiled the kernel:
    size_t bufferSize = 1024;
    uint32_t initValue = 42;
    callInitializeBuffer(context, queue, kernel, bufferSize, initValue);
*/