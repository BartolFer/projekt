#ifdef TESTING

#ifndef VSCODE_ONLY
	#hdr
		#include <cstdint>
		#include "./Test.hpp"
		#include "./kernels.cl.hpp"
	#end
	#src
		#include <iostream>
		#include <vector>
		#include "./MyOpenCL.hpp"
		#include "./Util.hpp"
		#include "./Huffman.hpp"
		#include "./Context.hpp"
	#end
#else // if VSCODE
	#include <cstdint>
	#include "./Test.hpp"
	#include "./kernels.cl.hpp"
	#include <iostream>
	#include <vector>
	#include "./MyOpenCL.hpp"
	#include "./Util.hpp"
	#include "./Huffman.hpp"
	#include "./Context.hpp"
	#include "./KernelsTest.hpp"
#endif

#define PRINT_ARRAY_10(arr) "["\
	<< ((arr)[0]) << ", " \
	<< ((arr)[1]) << ", " \
	<< ((arr)[2]) << ", " \
	<< ((arr)[3]) << ", " \
	<< ((arr)[4]) << ", " \
	<< ((arr)[5]) << ", " \
	<< ((arr)[6]) << ", " \
	<< ((arr)[7]) << ", " \
	<< ((arr)[8]) << ", " \
	<< ((arr)[9]) << ", " \
<< "]"

#define PRINT_X_MATRIX(mat, h, w) {                         \
    for (int i = 0; i < (w); ++i) { printf(" %2d", i); }    \
    printf("\n");                                           \
    for (int i = 0; i < (h); ++i) {                         \
        for (int j = 0; j < (w); ++j) {                     \
            u32 v = (mat)[i][j];                            \
            if (v == x) { printf("  x"); }                 \
            else        { printf(" %2u", v); }              \
        }                                                   \
        printf("\n");                                       \
    }                                                       \
}

namespace BJpeg {
	namespace {
		Kernels kernels_var;
		
		std :: vector<i16[64]> inflateTo64Coefficients(std :: vector<i16> dc_coefficients) {
			std :: vector<i16[64]> result; result.reserve(64 * dc_coefficients.size());
			int index = 0;
			for (auto x : dc_coefficients) {
				result[index][0] = x;
				for (int i = 1; i < 64; ++i) {
					result[index][i] = i;
					//	or any random value (but consistent between calls (we want that coefficients and expected have same ACs (in prefixSum test)))
				}
			}
			return result;
		}
		
		struct KernelsTest : Test {
			virtual bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) = 0;
			virtual bool test() {
				cl_device_id device_id;
				if (!MyOpenCL :: getDeviceId(device_id)) { return false; }
				
				Resource<MyOpenCL :: Context> context(device_id);               if (!context) { return false; }
				Resource<MyOpenCL :: Queue>   queue(device_id, context);        if (!queue  ) { return false; }
				Resource<MyOpenCL :: Program> program(device_id, context, BJpeg::kernels); if (!program) { return false; }
				
				return self.kernelTest(context, queue, program);
			}
		};
		
		struct BufferSetter {
			MyOpenCL :: Kernel<1> kernel;
			bool init(MyOpenCL :: Program program) { return self.kernel.init(program, "initializeBufferU32"); }
			void finish() { self.kernel.finish(); }
			bool operator ()(MyOpenCL :: Queue queue, MyOpenCL :: Buffer<uint32_t> buffer, uint32_t value) {
				self.kernel.resetArgs();
				if (!self.kernel.setArg(buffer)) { return false; }
				if (!self.kernel.setArg(value)) { return false; }
				
				size_t work[1] = { buffer.length };
				if (!self.kernel (queue, work)) { return false; }
				//	if (!self.kernel (queue, &buffer.length)) { return false; } // because we can't have nice things
				return true;
			}
		};
		struct Test_decodeHuffman1 : KernelsTest {
			char const* getDescription() { return "Test decodeHuffman1"; }
			bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.decodeHuffman1, program);
				if (!kernel) { return false; }
				
				constexpr uint32_t const B2 = 14;
				constexpr uint32_t const lane_width = 128;
				constexpr uint8_t const lanes_count = 3;
				constexpr uint8_t const depth = 5;
				constexpr uint8_t  const prev_size_pow = 0;
				uint32_t const x = ~(uint32_t)0;
				
				HuffmanTree<CodingType :: DECODE> trees_arr[2][4] = {
					{
						{.nodes={{1, 4}, {2, 3}, {0, 3}, {0, 6}, {5, 8}, {6, 7}, {0, 7}, {0, 4}, {9, 10}, {0, 5}, {11, 12}, {0, 2}, {1, 0}}},
						{.nodes={{1, 2}, {0, 2}, {3, 4}, {0, 5}, {5, 6}, {0, 4}, {7, 8}, {0, 3}, {1, 0}}},
					},
					{
						{.nodes={{1, 14}, {2, 5}, {3, 4}, {0, 213}, {0, 149}, {6, 9}, {7, 8}, {0, 0}, {0, 197}, {10, 11}, {0, 20}, {12, 13}, {0, 5}, {0, 85}, {15, 34}, {16, 23}, {17, 20}, {18, 19}, {0, 212}, {0, 164}, {21, 22}, {0, 133}, {0, 147}, {24, 27}, {25, 26}, {0, 69}, {0, 228}, {28, 31}, {29, 30}, {0, 4}, {0, 148}, {32, 33}, {0, 53}, {0, 21}, {35, 58}, {36, 43}, {37, 40}, {38, 39}, {0, 99}, {0, 3}, {41, 42}, {0, 67}, {0, 131}, {44, 51}, {45, 48}, {46, 47}, {0, 84}, {0, 100}, {49, 50}, {0, 244}, {0, 180}, {52, 55}, {53, 54}, {0, 181}, {0, 196}, {56, 57}, {0, 229}, {0, 245}, {59, 74}, {60, 67}, {61, 64}, {62, 63}, {0, 227}, {0, 195}, {65, 66}, {0, 179}, {0, 68}, {68, 71}, {69, 70}, {0, 116}, {0, 243}, {72, 73}, {0, 115}, {0, 35}, {75, 82}, {76, 79}, {77, 78}, {0, 51}, {0, 37}, {80, 81}, {0, 211}, {0, 83}, {83, 90}, {84, 87}, {85, 86}, {0, 101}, {0, 52}, {88, 89}, {0, 117}, {0, 165}, {91, 94}, {92, 93}, {0, 240}, {0, 36}, {95, 98}, {96, 97}, {0, 163}, {0, 19}, {99, 100}, {0, 132}, {1, 0}}},
						{.nodes={{1, 12}, {2, 5}, {3, 4}, {0, 99}, {0, 116}, {6, 9}, {7, 8}, {0, 243}, {0, 240}, {10, 11}, {0, 244}, {0, 164}, {13, 28}, {14, 19}, {15, 16}, {0, 179}, {17, 18}, {0, 131}, {0, 67}, {20, 23}, {21, 22}, {0, 36}, {0, 35}, {24, 25}, {0, 100}, {26, 27}, {0, 115}, {0, 52}, {29, 44}, {30, 37}, {31, 34}, {32, 33}, {0, 212}, {0, 227}, {35, 36}, {0, 20}, {0, 132}, {38, 41}, {39, 40}, {0, 228}, {0, 0}, {42, 43}, {0, 196}, {0, 195}, {45, 52}, {46, 49}, {47, 48}, {0, 83}, {0, 4}, {50, 51}, {0, 51}, {0, 84}, {53, 58}, {54, 55}, {0, 148}, {56, 57}, {0, 211}, {0, 68}, {59, 62}, {60, 61}, {0, 3}, {0, 180}, {63, 66}, {64, 65}, {0, 163}, {0, 19}, {67, 68}, {0, 147}, {1, 0}}},
					},
				};
				uint8_t payload_arr[] = {237, 195, 199, 49, 126, 100, 208, 114, 185, 102, 90, 179, 218, 255, 255, 255};
				LaneInfo lane_infos_arr[lanes_count] = {{0, 0, 0, 16, 16}, {1, 0, 0, 16, 16}, {2, 1, 1, 16, 16}, };

				uint32_t initial[depth][lanes_count][lane_width] = {
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
				};
				uint32_t result  [depth][lanes_count][lane_width] = {{{0}}};
				uint8_t lane_indexes_arr[2] = {0, 2};
				
				Resource<MyOpenCL :: Buffer<uint8_t>> payload(context, CL_MEM_READ_ONLY, sizeof(payload_arr));
				if (!payload) { return false; }
				if (!payload.write(queue, payload_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<HuffmanTree<CodingType :: DECODE>[4]>> trees(context, CL_MEM_READ_ONLY, 2);
				if (!trees) { return false; }
				if (!trees.write(queue, trees_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<LaneInfo>> lane_infos(context, CL_MEM_READ_ONLY, lanes_count);
				if (!lane_infos) { return false; }
				if (!lane_infos.write(queue, lane_infos_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<uint32_t>> lanes(context, CL_MEM_READ_WRITE, depth * lanes_count * lane_width);
				if (!lanes) { return false; }
				if (!lanes.write(queue, &initial[0][0][0])) { return false; }
				Resource<MyOpenCL :: Buffer<uint8_t>> lane_indexes(context, CL_MEM_READ_ONLY, 2);
				if (!lane_indexes) { return false; }
				if (!lane_indexes.write(queue, &lane_indexes_arr[0])) { return false; }
				
				if (!kernel.setArg_payload     (payload     )) { return false; }
				if (!kernel.setArg_B2          (B2          )) { return false; }
				if (!kernel.setArg_trees       (trees       )) { return false; }
				if (!kernel.setArg_lane_infos  (lane_infos  )) { return false; }
				if (!kernel.setArg_lanes       (lanes       )) { return false; }
				if (!kernel.setArg_lane_width  (lane_width  )) { return false; }
				if (!kernel.setArg_lane_indexes(lane_indexes)) { return false; }
				
				size_t global_work[2] = { 2, 8*B2 };
				if (!kernel(queue, global_work)) { return false; }
				
				if (!lanes.read(queue, &result[0][0][0])) { return false; }
				if (result[0][0][0] != 54) {
					Test :: getError() << "[0][0][0]: e=" << 54 << " v=" << result[0][0][0] << std :: endl;
					return false;
				}
				if (result[0][2][54] != 51) {
					Test :: getError() << "[0][2][54]: e=" << 51 << " v=" << result[0][2][54] << std :: endl;
					return false;
				}
				if (result[0][0][54 + 51] != x) {
					Test :: getError() << "[0][0][54 + 51]: e=x=" << x << " v=" << result[0][0][54 + 51] << std :: endl;
					return false;
				}
				
				return true;
			}
		};
		struct Test_decodeRaise : KernelsTest {
			char const* getDescription() { return "Test decodeRaise"; }
			bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.decodeRaise, program);
				if (!kernel) { return false; }
				
				constexpr uint32_t const lane_width = 64;
				constexpr uint8_t const lanes_count = 4;
				constexpr uint8_t const depth = 5;
				constexpr uint8_t  const prev_size_pow = 0;
				uint32_t const x = ~(uint32_t)0;
				uint32_t initial[depth][lanes_count][lane_width] = {
					{
						{3,2,1,4,3,2,1,x,4,3,2,1,4,3,2,1,3,2,1,2,1,3,2,1,x,4,3,2,1,1,4,3,2,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{3,2,1,4,3,2,1,x,4,3,2,1,4,3,2,1,3,2,1,2,1,3,2,1,x,4,3,2,1,1,4,3,2,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{3,2,1,4,3,2,1,5,4,3,2,1,4,3,2,1,3,2,1,2,1,3,2,1,5,4,3,2,1,1,4,3,2,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{3,3,2,4,3,3,2,5,4,3,3,2,4,3,3,2,3,3,2,3,2,3,3,2,5,4,3,3,2,2,4,3,3,2,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
				};
				uint32_t result  [depth][lanes_count][lane_width] = {{{0}}};
				uint32_t expected[depth][lanes_count][lane_width] = {
					{
						{3,2,1,4,3,2,1,x,4,3,2,1,4,3,2,1,3,2,1,2,1,3,2,1,x,4,3,2,1,1,4,3,2,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{3,2,1,4,3,2,1,x,4,3,2,1,4,3,2,1,3,2,1,2,1,3,2,1,x,4,3,2,1,1,4,3,2,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{3,2,1,4,3,2,1,5,4,3,2,1,4,3,2,1,3,2,1,2,1,3,2,1,5,4,3,2,1,1,4,3,2,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{3,3,2,4,3,3,2,5,4,3,3,2,4,3,3,2,3,3,2,3,2,3,3,2,5,4,3,3,2,2,4,3,3,2,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{7,6,5,x,x,x,x,x,8,7,6,5,7,6,5,4,5,4,3,5,4,x,x,x,x,5,4,3,2,5,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{7,6,5,9,8,7,6,9,8,7,6,5,7,6,5,4,6,5,4,5,4,8,7,6,7,6,5,4,3,5,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
				};
				
				Resource<MyOpenCL :: Buffer<uint32_t>> lanes(context, CL_MEM_READ_WRITE, depth * lanes_count * lane_width);
				if (!lanes) { return false; }
				if (!lanes.write(queue, &initial[0][0][0])) { return false; }
				
				if (!kernel.setArg_lanes(lanes)) { return false; }
				if (!kernel.setArg_lane_width(lane_width)) { return false; }
				if (!kernel.setArg_lanes_count(lanes_count)) { return false; }
				if (!kernel.setArg_prev_size_pow(prev_size_pow)) { return false; }
				
				size_t global_work[2] = { 2, lane_width };
				if (!kernel(queue, global_work)) { return false; }
				
				if (!lanes.read(queue, &result[0][0][0])) { return false; }
				for (uint32_t d = 0; d < depth; ++d) {
					for (uint32_t l = 0; l < lanes_count; ++l) {
						for (uint32_t i = 0; i < lane_width; ++i) {
							if (result[d][l][i] != expected[d][l][i]) {
								Test :: getError() << "[" << d << "][" << l << "][" << i << "]: e=" << expected[d][l][i] << " v=" << result[d][l][i] << std :: endl;
								return false;
							}
						}
					}
				}
				
				return true;
			}
		};
		struct Test_decodeLower : KernelsTest {
			char const* getDescription() { return "Test decodeLower"; }
			bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.decodeLower, program);
				if (!kernel) { return false; }
				Resource<BufferSetter> set_buf(program);
				if (!set_buf) { return false; }
				
				constexpr uint32_t const lane_width = 64;
				constexpr uint8_t const lanes_count = 4;
				constexpr uint8_t const depth = 5;
				uint32_t const x = ~(uint32_t)0;
				uint32_t initial[depth][lanes_count][lane_width] = {
					{
						{ 3, 2, 1, 4, 3, 2, 1, x, 4, 3, 2, 1, 4, 3, 2, 1, 3, 2, 1, 2, 1, 3, 2, 1, x, 4, 3, 2, 1, 1, 4, 3, 2, 1, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ 3, 2, 1, 4, 3, 2, 1, x, 4, 3, 2, 1, 4, 3, 2, 1, 3, 2, 1, 2, 1, 3, 2, 1, x, 4, 3, 2, 1, 1, 4, 3, 2, 1, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ 3, 2, 1, 4, 3, 2, 1, 5, 4, 3, 2, 1, 4, 3, 2, 1, 3, 2, 1, 2, 1, 3, 2, 1, 5, 4, 3, 2, 1, 1, 4, 3, 2, 1, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ 3, 3, 2, 4, 3, 3, 2, 5, 4, 3, 3, 2, 4, 3, 3, 2, 3, 3, 2, 3, 2, 3, 3, 2, 5, 4, 3, 3, 2, 2, 4, 3, 3, 2, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
					},
					{
						{ 7, 6, 5, x, x, x, x, x, 8, 7, 6, 5, 7, 6, 5, 4, 5, 4, 3, 5, 4, x, x, x, x, 5, 4, 3, 2, 5, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ 7, 6, 5, 9, 8, 7, 6, 9, 8, 7, 6, 5, 7, 6, 5, 4, 6, 5, 4, 5, 4, 8, 7, 6, 7, 6, 5, 4, 3, 5, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
					},
					{
						{16,15,14, x, x, x, x, x,14,13,12,11,12,11,10, 9,13,12,11,12,11, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
					},
					{
						{29,28,27, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
					},
					{
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
					},
				};
				uint32_t result  [lanes_count][lane_width + 8] = {{{0}}};
				uint32_t expected[lanes_count][lane_width] = {
					{0,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,4,x,x,x,x,x,x,x,x,x,x,x,x,8,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					{x,x,x,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,5,x,x,x,x,x,x,x,x,x,x,9,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					{x,x,x,x,x,x,x,2,x,x,x,x,x,x,x,x,x,x,x,x,x,6,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					{x,x,x,x,x,x,x,x,x,x,x,x,3,x,x,x,x,x,x,x,x,x,x,x,7,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
				};
				
				Resource<MyOpenCL :: Buffer<uint32_t>> positions(context, CL_MEM_READ_WRITE, lanes_count * (lane_width + 8));
				if (!positions) { return false; }
				if (!set_buf(queue, positions, x)) { return false; }
				uint32_t zero = 0;
				if (!positions.write(queue, &zero, 1)) { return false; }
				Resource<MyOpenCL :: Buffer<uint32_t>> lanes(context, CL_MEM_READ_WRITE, depth * lanes_count * lane_width);
				if (!lanes) { return false; }
				if (!lanes.write(queue, &initial[0][0][0])) { return false; }
				
				if (!kernel.setArg_positions  (positions)) { return false; }
				if (!kernel.setArg_lanes      (lanes)) { return false; }
				if (!kernel.setArg_lane_width (lane_width)) { return false; }
				if (!kernel.setArg_lanes_count(lanes_count)) { return false; }
				
				uint8_t size_pow;
				size_t global_work[2] = { lanes_count, lane_width };

				size_pow = 3;
				global_work[0] = 1;
				if (!kernel.setArg_size_pow(size_pow)) { return false; }
				if (!kernel(queue, global_work)) { return false; }
				if (!positions.read(queue, &result[0][0])) { return false; }
				size_pow = 2;
				global_work[0] = 1;
				if (!kernel.setArg_size_pow(size_pow)) { return false; }
				if (!kernel(queue, global_work)) { return false; }
				if (!positions.read(queue, &result[0][0])) { return false; }
				size_pow = 1;
				global_work[0] = 1;
				if (!kernel.setArg_size_pow(size_pow)) { return false; }
				if (!kernel(queue, global_work)) { return false; }
				if (!positions.read(queue, &result[0][0])) { return false; }
				size_pow = 0;
				global_work[0] = 2;
				if (!kernel.setArg_size_pow(size_pow)) { return false; }
				if (!kernel(queue, global_work)) { return false; }
				
				if (!positions.read(queue, &result[0][0])) { return false; }
				for (uint32_t l = 0; l < lanes_count; ++l) {
					for (uint32_t i = 0; i < 34; ++i) { //	hardcoded
						if (result[l][i] != expected[l][i]) {
							Test :: getError() << "[" << l << "][" << i << "]: e=" << expected[l][i] << " v=" << result[l][i] << std :: endl;
							return false;
						}
					}
				}
				
				return true;
			}
		};
		struct Test_positionsToIndexes : KernelsTest {
			char const* getDescription() { return "Test positionsToIndexes"; }
			bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.positionsToIndexes, program);
				if (!kernel) { return false; }
				Resource<BufferSetter> set_buf(program);
				if (!set_buf) { return false; }
				
				constexpr uint32_t const lane_width = 64;
				constexpr uint8_t const lanes_count = 4;
				constexpr uint8_t const depth = 5;
				uint32_t const x = ~(uint32_t)0;
				
				uint32_t initial[lanes_count][lane_width + 8] = {
					{0,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,4,x,x,x,x,x,x,x,x,x,x,x,x,8,x,x,x,x, x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x, x,x,x,x, x,x,x,x,},
					{x,x,x,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,5,x,x,x,x,x,x,x,x,x,x,9,x,x,x, x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x, x,x,x,x, x,x,x,x,},
					{x,x,x,x,x,x,x,2,x,x,x,x,x,x,x,x,x,x,x,x,x,6,x,x,x,x,x,x,x,x,x,x,x,x,10,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x, x,x,x,x, x,x,x,x,},
					{x,x,x,x,x,x,x,x,x,x,x,x,3,x,x,x,x,x,x,x,x,x,x,x,7,x,x,x,x,x,x,x,x,x, x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x, x,x,x,x, x,x,x,x,},
				};
				cl_uint2 result  [11] = {0};
				cl_uint2 expected[11] = {{{0,0}}, {{1,3}}, {{2,7}}, {{3,12}}, {{0,16}}, {{1,19}}, {{2,21}}, {{3,24}}, {{0,29}}, {{1,30}}, {{2,34}}};
				
				Resource<MyOpenCL :: Buffer<uint32_t>> positions(context, CL_MEM_READ_WRITE, lanes_count * (lane_width + 8));
				if (!positions) { return false; }
				if (!positions.write(queue, &initial[0][0])) { return false; }
				Resource<MyOpenCL :: Buffer<cl_uint2>> indexes(context, CL_MEM_READ_WRITE, 16);
				if (!indexes) { return false; }
				if (!indexes.write(queue, result)) { return false; }
				
				if (!kernel.setArg_positions (positions )) { return false; }
				if (!kernel.setArg_indexes   (indexes   )) { return false; }
				if (!kernel.setArg_lane_width(lane_width)) { return false; }
				
				size_t global_work[2] = { lanes_count, lane_width };
				if (!kernel(queue, global_work)) { return false; }
				if (!indexes.read(queue, &result[0])) { return false; }
				
				for (int i = 0; i <= 10; ++i) {
					if (result[i].s[0] != expected[i].s[0] || result[i].s[1] != expected[i].s[1]) {
						Test :: getError() << "[" << i << "]: e=(" << expected[i].s[0] << "," << expected[i].s[1] << ")" << " v=(" << result[i].s[0] << "," << result[i].s[1] << ")" << std :: endl;
						return false;
					}
				}
				
				return true;
			}
		};
		struct Test_decodeHuffman2 : KernelsTest {
			char const* getDescription() { return "Test decodeHuffman2"; }
			bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.decodeHuffman2, program);
				if (!kernel) { return false; }
				
				constexpr uint32_t const B2 = 14;
				constexpr uint32_t const lane_width = 128;
				constexpr uint8_t const lanes_count = 3;
				constexpr uint8_t const unit_count = 2;
				constexpr uint8_t const depth = 5;
				uint32_t const x = ~(uint32_t)0;
				
				HuffmanTree<CodingType :: DECODE> trees_arr[2][4] = {
					{
						{.nodes={{1, 4}, {2, 3}, {0, 3}, {0, 6}, {5, 8}, {6, 7}, {0, 7}, {0, 4}, {9, 10}, {0, 5}, {11, 12}, {0, 2}, {1, 0}}},
						{.nodes={{1, 2}, {0, 2}, {3, 4}, {0, 5}, {5, 6}, {0, 4}, {7, 8}, {0, 3}, {1, 0}}},
					},
					{
						{.nodes={{1, 14}, {2, 5}, {3, 4}, {0, 213}, {0, 149}, {6, 9}, {7, 8}, {0, 0}, {0, 197}, {10, 11}, {0, 20}, {12, 13}, {0, 5}, {0, 85}, {15, 34}, {16, 23}, {17, 20}, {18, 19}, {0, 212}, {0, 164}, {21, 22}, {0, 133}, {0, 147}, {24, 27}, {25, 26}, {0, 69}, {0, 228}, {28, 31}, {29, 30}, {0, 4}, {0, 148}, {32, 33}, {0, 53}, {0, 21}, {35, 58}, {36, 43}, {37, 40}, {38, 39}, {0, 99}, {0, 3}, {41, 42}, {0, 67}, {0, 131}, {44, 51}, {45, 48}, {46, 47}, {0, 84}, {0, 100}, {49, 50}, {0, 244}, {0, 180}, {52, 55}, {53, 54}, {0, 181}, {0, 196}, {56, 57}, {0, 229}, {0, 245}, {59, 74}, {60, 67}, {61, 64}, {62, 63}, {0, 227}, {0, 195}, {65, 66}, {0, 179}, {0, 68}, {68, 71}, {69, 70}, {0, 116}, {0, 243}, {72, 73}, {0, 115}, {0, 35}, {75, 82}, {76, 79}, {77, 78}, {0, 51}, {0, 37}, {80, 81}, {0, 211}, {0, 83}, {83, 90}, {84, 87}, {85, 86}, {0, 101}, {0, 52}, {88, 89}, {0, 117}, {0, 165}, {91, 94}, {92, 93}, {0, 240}, {0, 36}, {95, 98}, {96, 97}, {0, 163}, {0, 19}, {99, 100}, {0, 132}, {1, 0}}},
						{.nodes={{1, 12}, {2, 5}, {3, 4}, {0, 99}, {0, 116}, {6, 9}, {7, 8}, {0, 243}, {0, 240}, {10, 11}, {0, 244}, {0, 164}, {13, 28}, {14, 19}, {15, 16}, {0, 179}, {17, 18}, {0, 131}, {0, 67}, {20, 23}, {21, 22}, {0, 36}, {0, 35}, {24, 25}, {0, 100}, {26, 27}, {0, 115}, {0, 52}, {29, 44}, {30, 37}, {31, 34}, {32, 33}, {0, 212}, {0, 227}, {35, 36}, {0, 20}, {0, 132}, {38, 41}, {39, 40}, {0, 228}, {0, 0}, {42, 43}, {0, 196}, {0, 195}, {45, 52}, {46, 49}, {47, 48}, {0, 83}, {0, 4}, {50, 51}, {0, 51}, {0, 84}, {53, 58}, {54, 55}, {0, 148}, {56, 57}, {0, 211}, {0, 68}, {59, 62}, {60, 61}, {0, 3}, {0, 180}, {63, 66}, {64, 65}, {0, 163}, {0, 19}, {67, 68}, {0, 147}, {1, 0}}},
					},
				};
				uint8_t payload_arr[] = {237, 195, 199, 49, 126, 100, 208, 114, 185, 102, 90, 179, 218, 255, 255, 255};
				LaneInfo lane_infos_arr[lanes_count] = {{0, 0, 0, 16, 16}, {1, 0, 0, 16, 16}, {2, 1, 1, 16, 16}, };
				cl_uint2 indexes_arr[unit_count] = {
					{0, 0},
					{2, 54},
				};

				struct {
					uint8_t SSSS;
					uint16_t bits;
				} expected[unit_count][64] = {
					{{2, 0b11}, {5, 0b00011}, {3, 0b110}, {0,0}      , {4, 0b0010}, {0,0}      , {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {3, 0b011}, }, 
					{{2, 0b00}, {4, 0b0101} , {0,0}     , {4, 0b1100}, {0,0}      , {4, 0b1101}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}     , {3, 0b110}, },
				};
					//	1110-11 01110-00011 110001-110 0110-0010 11111100 110010-011 0100
					//	0-00 111001-0101 110010-1100 110010-1101 0101 10011-110 110101
					//	11111111111111111111111
				int16_t result_arr[unit_count][64];
				
				Resource<MyOpenCL :: Buffer<uint8_t>> payload(context, CL_MEM_READ_ONLY, sizeof(payload_arr));
				if (!payload) { return false; }
				if (!payload.write(queue, payload_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<HuffmanTree<CodingType :: DECODE>[4]>> trees(context, CL_MEM_READ_ONLY, 2);
				if (!trees) { return false; }
				if (!trees.write(queue, trees_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<LaneInfo>> lane_infos(context, CL_MEM_READ_ONLY, lanes_count);
				if (!lane_infos) { return false; }
				if (!lane_infos.write(queue, lane_infos_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<cl_uint2>> indexes(context, CL_MEM_READ_ONLY, 2);
				if (!indexes) { return false; }
				if (!indexes.write(queue, indexes_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<i16[64]>> result(context, CL_MEM_READ_WRITE, 2);
				if (!result) { return false; }
				
				if (!kernel.setArg_payload     (payload   )) { return false; }
				if (!kernel.setArg_trees       (trees     )) { return false; }
				if (!kernel.setArg_lane_infos  (lane_infos)) { return false; }
				if (!kernel.setArg_lane_width  (lane_width)) { return false; }
				if (!kernel.setArg_indexes     (indexes   )) { return false; }
				if (!kernel.setArg_coefficients(result    )) { return false; }
				
				size_t global_work[1] = { unit_count };
				if (!kernel(queue, global_work)) { return false; }
				
				if (!result.read(queue, result_arr)) { return false; }
				for (int uint_id = 0; uint_id < unit_count; ++uint_id) {
					for (int i = 0; i < 64; ++i) {
						auto ex   = expected  [uint_id][i];
						int16_t r = result_arr[uint_id][i];
						if (ex.SSSS == 0) {
							if (r != 0) {
								Test :: getError() << "[" << uint_id << "][" << i << "]: 0 e=" << ex.SSSS << "|" << ex.bits << " v=" << r << "(" << std::hex << r << ")" << std :: endl;
								return false;
							}
						} else {
							int M = 1 << ex.SSSS;
							int m = M >> 1;
							int mask = M - 1;
							if (m <= r && r < M) {
								if (r & mask != ex.bits) {
									Test :: getError() << "[" << uint_id << "][" << i << "]: + e=" << ex.SSSS << "|" << std::hex << ex.bits << " v=" << r << "(" << std::hex << r << ")" << std :: endl;
									return false;
								}
							} else if (-M < r && r <= -m) {
								if ((r - 1) & mask != ex.bits) {
									Test :: getError() << "[" << uint_id << "][" << i << "]: - e=" << ex.SSSS << "|" << std::hex << ex.bits << " v=" << r << "(" << std::hex << r << ")" << std :: endl;
									return false;
								}
							} else {
								Test :: getError() << "[" << uint_id << "][" << i << "]: SSSS e=" << ex.SSSS << "|" << std::hex << ex.bits << " v=" << r << "(" << std::hex << r << ")" << std :: endl;
								return false;
							}
						}
					}
				}
				
				return true;
			}
		};
		struct Test_prepareMCUs : KernelsTest {
			char const* getDescription() { return "Test prepareMCUs"; }
			bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.prepareMCUs, program); if (!kernel) { return false; }
				
				//                                                               A  B  B  C
				auto coefficients_arr = inflateTo64Coefficients(std::vector<i16>{25,23,31,23, 31,28,27,27, 10,31,25,25, 18,27,28,29, 29,30,33,33});
				auto expected_arr     = inflateTo64Coefficients(std::vector<i16>{25,23,54,23, 31,28,55,27, 10,31,56,25, 18,27,55,29, 29,30,63,33});
				auto lane_infos_arr = std::vector{LaneInfo{.start_in_mcu = 1, .amount_in_mcu = 2}};
				
				size_t work[2] = {1, coefficients_arr.size()};
				u8 mcu_length = 4;
				
				Resource<MyOpenCL :: Buffer<i16[64]>> coefficients(context, CL_MEM_READ_WRITE, coefficients_arr.size()); if (!coefficients) { return false; }
				Resource<MyOpenCL :: Buffer<LaneInfo>>  lane_infos(context, CL_MEM_READ_WRITE,   lane_infos_arr.size()); if (!  lane_infos) { return false; }
				
				if (!coefficients.write(queue, &coefficients_arr[0])) { return false; }
				if (!  lane_infos.write(queue, &  lane_infos_arr[0])) { return false; }
				
				if (!kernel.setArg_coefficients(coefficients)) { return false; }
				if (!kernel.setArg_lane_infos  (lane_infos  )) { return false; }
				if (!kernel.setArg_mcu_length  (mcu_length  )) { return false; }
				if (!kernel(queue, work)) { return false; }
				
				if (!coefficients.read(queue, &coefficients_arr[0])) { return false; }
				for (int i = 0; i < coefficients_arr.size(); ++i) {
					//	TODO for 64
					if (coefficients_arr[i] != expected_arr[i]) {
						Test :: getError() << "Error at " << i << ": Expected " << expected_arr[i] << " Got " << coefficients_arr[i];
						return false;
					}
				}
				
				return true;
			}
		};
		template <int X> using PrefixSumKernel = void;
		template <> using PrefixSumKernel<1> = void;
		template <> using PrefixSumKernel<2> = void;
		typedef <int Prefix
		struct PrefixSumTest : KernelsTest {
			char const* kernel_name;
			char const* name;
			u8 mcu_length;
			u32 half_size;
			std :: vector<LaneInfo> lane_infos;
			std :: vector<i16[64]> coefficients;
			std :: vector<i16[64]> expected;
			PrefixSumTest(
				char const* kernel_name,
				char const* name,
				u8 mcu_length,
				u32 half_size,
				std :: vector<LaneInfo> lane_infos,
				std :: vector<i16> coefficients,
				std :: vector<i16> expected
			) :
				kernel_name(kernel_name),
				name(name),
				mcu_length(mcu_length),
				half_size(half_size),
				lane_infos(lane_infos),
				coefficients(inflateTo64Coefficients(coefficients)),
				expected(inflateTo64Coefficients(expected))
			{}
			
			char const* getDescription() { return self.name; }
			bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				//	TODO
				Resource kernel(kernels_var.elf, program); if (!kernel) { return false; }
				
				using Args = CLContext<DECODE> :: Kernels :: prefixSum1Args;
				
				if (self.coefficients.size() != self.expected.size()) { return false; }
				if (self.lane_infos.size() != mcu_length) { return false; }
				if (self.coefficients.size() / 64 % mcu_length != 0) { return false; }
				size_t n = self.coefficients.size() / 64 / mcu_length;
				
				Resource<MyOpenCL :: Buffer<i16     >> coefficients(context, CL_MEM_READ_WRITE, self.coefficients.size()); if (!coefficients) { return false; }
				Resource<MyOpenCL :: Buffer<LaneInfo>> lane_infos  (context, CL_MEM_READ_WRITE, self.lane_infos  .size()); if (!lane_infos  ) { return false; }
				
				if (!coefficients.write(queue, &self.coefficients[0])) { return false; }
				if (!lane_infos  .write(queue, &self.lane_infos  [0])) { return false; }
				
				if (!kernel.setArg(coefficients, Args :: coefficients)) { return false; }
				if (!kernel.setArg(lane_infos  , Args :: lane_infos  )) { return false; }
				if (!kernel.setArg(mcu_length  , Args :: mcu_length  )) { return false; }
				if (!kernel.setArg(half_size   , Args :: half_size   )) { return false; }
				
				size_t amount = n / (2 * half_size);
				if (!kernel(queue, 1, &amount)) { return false; }
				
				if (!coefficients.read(queue, &self.coefficients[0])) { return false; }
				for (int i = 0; i < self.coefficients.size(); ++i) {
					if (self.coefficients[i] != self.expected[i]) {
						Test :: getError() << "Error at " << i << ": Expected " << self.expected[i] << " Got " << self.coefficients[i];
						return false;
					}
				}
				
				return true;
			}
		};
		struct Test_initializeBufferU32 : KernelsTest {
			char const* getDescription() { return "Test initializeBufferU32"; }
			bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.initializeBufferU32, program); if (!kernel) { return false; }
				
				size_t amount[1] = {1024};
				uint32_t value1 = 42;
				
				Resource<MyOpenCL :: Buffer<uint32_t>> device_buffer(context, CL_MEM_READ_WRITE, amount[0]); if (!device_buffer) { return false; }
				
				if (!kernel.setArg(device_buffer.buffer)) { return false; }
				if (!kernel.setArg(value1, 1)) { return false; }
				if (!kernel(queue, amount)) { return false; }
				
				uint32_t value2 = 33;
				if (!kernel.setArg(value2, 1)) { return false; }
				size_t offset2[1] = {1};
				size_t amount2[1] = {2};
				if (!kernel(queue, amount2, offset2)) { return false; }
				
				uint32_t my_buffer[10];
				
				if (!device_buffer.read(queue, my_buffer, 10)) { return false; }
				if (my_buffer[0] != value1) { std :: cerr << "Buffer wrong at 0: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[1] != value2) { std :: cerr << "Buffer wrong at 1: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[2] != value2) { std :: cerr << "Buffer wrong at 2: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[3] != value1) { std :: cerr << "Buffer wrong at 3: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[4] != value1) { std :: cerr << "Buffer wrong at 4: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[5] != value1) { std :: cerr << "Buffer wrong at 5: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[6] != value1) { std :: cerr << "Buffer wrong at 6: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[7] != value1) { std :: cerr << "Buffer wrong at 7: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[8] != value1) { std :: cerr << "Buffer wrong at 8: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[9] != value1) { std :: cerr << "Buffer wrong at 9: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				
				return true;
			}
		};
		
		namespace { 
			Test_decodeHuffman1      test_decodeHuffman1     ;
			Test_decodeRaise         test_decodeRaise        ;
			Test_decodeLower         test_decodeLower        ;
			Test_positionsToIndexes  test_positionsToIndexes ;
			Test_decodeHuffman2      test_decodeHuffman2     ;
			Test_prepareMCUs         test_prepareMCUs        ;
			//	PrefixSumTest{kernel_name, name, mcu_length, half_size, lane_infos, coefficients, expected, },
			PrefixSumTest test_prefixSum1_1_15 = {"prefixSum1", "Test prefixSum1 1 15", 1, 2, std::vector{LaneInfo{1}}, 
				std::vector<i16>{19, 29, 23, 33, 11, 11, 11, 30, 12, 26, 31, 11, 12, 21, 29}, 
				std::vector<i16>{19, 29, 23, 62, 11, 11, 11, 41, 12, 26, 31, 37, 12, 21, 29}
			};
			PrefixSumTest test_prefixSum1_1_16 = {"prefixSum1", "Test prefixSum1 1 16", 1, 2, std::vector{LaneInfo{1}}, 
				std::vector<i16>{28, 22, 11, 24, 26, 26, 11, 33, 26, 30, 21, 12, 24, 32, 24, 18}, 
				std::vector<i16>{28, 22, 11, 46, 26, 26, 11, 59, 26, 30, 21, 42, 24, 32, 24, 50}
			};
			PrefixSumTest test_prefixSum1_1_17 = {"prefixSum1", "Test prefixSum1 1 17", 1, 2, std::vector{LaneInfo{1}}, 
				std::vector<i16>{27, 26, 21, 23, 27, 30, 21, 24, 32, 21, 27, 15, 15, 14, 18, 32, 13}, 
				std::vector<i16>{27, 26, 21, 49, 27, 30, 21, 54, 32, 21, 27, 36, 15, 14, 18, 46, 13}
			};
			PrefixSumTest test_prefixSum1_1_18 = {"prefixSum1", "Test prefixSum1 1 18", 1, 2, std::vector{LaneInfo{1}}, 
				std::vector<i16>{31, 21, 14, 26, 10, 19, 28, 22, 10, 24, 30, 32, 28, 22, 25, 25, 26, 29}, 
				std::vector<i16>{31, 21, 14, 47, 10, 19, 28, 41, 10, 24, 30, 56, 28, 22, 25, 47, 26, 29}
			};

			PrefixSumTest test_prefixSum1_4 = {"prefixSum1", "Test prefixSum1 4", 4, 1, std::vector{LaneInfo{1}, LaneInfo{2}, LaneInfo{2}, LaneInfo{3}, }, 
				//	MCU = ABBC
				//	NCU = (A, B, BB, C)
				// NCU1 + NCU2 = (A1+A2, BB1+B2, BB1+BB2, C1+C2)
				std::vector<i16>{25,23,31,23, 31,28,27,27, 10,31,25,25, 18,27,28,29, 29,30,33,33},
				std::vector<i16>{25,23,31,23, 56,59,58,50, 10,31,25,25, 28,52,53,54, 29,30,33,33}
			};
			Test_initializeBufferU32 test_initializeBufferU32;
		}
	}
}


#endif