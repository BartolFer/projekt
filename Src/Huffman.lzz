#ifndef VSCODE_ONLY
	#hdr
		#pragma once
		#include <cstdint>
		#include <iostream>
		#include "./FileBuffer.hpp"
		#include "./Util.hpp"
	#end
	#src
		#include <string.h>
	#end
#else // if VSCODE
	#include <string.h>
	#include <cstdint>
	#include <iostream>
	#include "./Huffman.hpp"
	#include "./FileBuffer.hpp"
	#include "./Util.hpp"
#endif

namespace BJpeg {
	struct ValueAndLength {
		u16 length;
		u16 value;
	};
	struct CodeAndLength {
		u16 length;
		u16 code;
	};
	template <CodingType CODING_TYPE>
	struct HuffmanTree;
	template <>
	struct HuffmanTree<CodingType :: DECODE> {
		void reset() {
			memset(self.nodes, 0, sizeof(self.nodes));
		}
		void update(u16 code, uint8_t length, uint8_t value, u16& last_assigned_index) {
			u16 node = 0;
			for (uint8_t i = length; i > 0; --i) {
				auto bit = (code >> (i - 1)) & 1;
				auto& box = bit == 0 ? self.nodes[node].left : self.nodes[node].right_or_data;
				if (box == 0) { box = ++last_assigned_index; }
				node = box;
			}
			self.nodes[node] = { 0, value };
		}
		void setLastNode(uint8_t last_length) {
			u16 node = 0;
			for (uint8_t i = last_length; i > 0; --i) {
				node = self.nodes[node].right_or_data;
			}
			self.nodes[node] = { 1, 0 };
		}
		
		ValueAndLength operator [](u16 bits) {
			u16 index = 0;
			for (u16 depth = 0; ; ++depth) {
				auto node = self.nodes[index];
				if (node.left == 0) {
					return {depth, node.right_or_data};
				}
				index = (bits >> 15) == 0 ? node.left : node.right_or_data;
				bits <<= 1;
			}
		}
		// TODO GPU data
		
		void printToFile(FILE* file) {
			int highest_r = 0;
			for (int i = 0; i <= highest_r; ++i) {
				auto node = self.nodes[i];
				if (node.left == 0) { fprintf(file, "    %3u|",            node.right_or_data); }
				else                { fprintf(file, "%3u,%3u|", node.left, node.right_or_data); highest_r = node.right_or_data; }
			}
		}
		
		// might be possible with u8 by using offsets (but i couldn't be bothered to verify that)
		struct Node {               // either {0, data} or {left, right}
			u16 left;          // if left == 0, then next byte is data
			u16 right_or_data; // else, left and right are indexes of left and right nodes
		};
		typedef Node Nodes[256 + 255 + 1];
		Nodes nodes; 
			// tree is full, which means that number of inner nodes = number of leaves - 1
			// there is at most 256 values (leaves) in jpg, since values are 8 bit
			// 256 + 255 (+1 for alignment)
		
			// going sequentially through this array is equivalent to pre-order traversal
		typedef Nodes CLType;
	};
	
	template <>
	struct HuffmanTree<CodingType :: ENCODE> {
		typedef u16 CLType;
		CodeAndLength operator [](uint8_t value) {
			return {0, 0};
		}
		
	#ifndef DEBUG
	private:
	#endif
	};
}