#pragma region zzc hdr_decl
	#include <iostream>
	#include <cstdint>
	#include <string>
#pragma endregion zzc
#pragma region zzc src_decl
	#include <filesystem>
	#include "../Test.zzh"
#pragma endregion zzc
#include "../Util.zzh"



namespace BJpeg {
	namespace Decode {
		namespace {
			fun size_t freadExactlly(u8* dst, size_t elm_size, size_t count, FILE* file) {
				size_t amount_read = 0;
				while (count) {
					amount_read += fread(dst, elm_size, count, file);
					count -= amount_read;
					dst += amount_read;
					if (feof(file)) { break; }
				}
				return amount_read;
			}
			
			struct RAIIFileHandle {
				FILE* const file;
				fun RAIIFileHandle(std :: string& path) : file(fopen(path.c_str(), "rb")) {}
				fun ~RAIIFileHandle() { fclose(self.file); }
				fun operator bool() { return self.file != nullptr; }
			};
		}
		
		struct InputFileBuffer {
			uintmax_t length = 0;
			u8* buffer = nullptr;
			// std :: ifstream file;
			
			fun bool init(std :: string& path) {
				self.length = std :: filesystem :: file_size(path);
				self.buffer = new u8[self.length];
				if (!self.buffer) { return false; }
				RAIIFileHandle file(path);
				if (!file) { return false; }
				if (fread(self.buffer, 1, self.length, file.file) != self.length) { return false; }
				return true;
			}
			fun void finish() noexcept {
				delete[] self.buffer;
			}
			fun u8 const& operator [](int index) {
				return self.buffer[index];
			}
		};
		
		//	#ifdef TESTING
		//		namespace {
		//			class MyTest : Test {
		//				char const* getDescription() { return "InputFileBuffer Test"; }
		//				static char const* const path = "./_InputFileBufferTestFile_690074.bin";
		//				static unsigned const half_block_size_pow = 3; // 8 bytes
		//				static char blocks[4] = {
		//					0x11,
		//					0x22,
		//					0x33,
		//					0x44,
		//				};
		//				void writeHalfBlock(char data, FILE* file) {
		//					for (int i = 0; i < (1 << half_block_size_pow); ++i) {
		//						fwrite(&data, 1, 1, file);
		//					}
		//				}
		//				void init() {
		//					FILE* file = fopen(path, "wb");
		//					for (auto data : blocks) { writeHalfBlock(data, file); }
		//					fflush(file);
		//					fclose(file);
		//				}
		//				bool test() {
		//					InputFileBuffer buffer(half_block_size_pow, std :: string(path));
		//					
		//					int index = 0;
		//					for (auto data : blocks) { 
		//						for (int i = 0; i < (1 << half_block_size_pow); ++i, ++index) { 
		//							if (buffer[index] != data) {
		//								fprintf(stderr, "Failed because 0x%X != 0x%X [%d]\n", buffer[index], data, i);
		//								for (int j = 0; j < 2*(1 << half_block_size_pow); ++j) { 
		//									fprintf(stderr, "%02X ", buffer.buffer[j]);
		//								}
		//								fprintf(stderr, "\n h = %d", buffer.head);
		//								return false;
		//							}
		//						}
		//					}
		//					return true;
		//				}
		//				void finish() {
		//					remove(path);
		//				}
		//			};
		//			MyTest test;
		//		}
		//	#endif
	}
}