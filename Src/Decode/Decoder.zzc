#include "./DecoderMacro.zzh"
#include "../Util.zzh"
#pragma region zzc hdr_decl
	#include <cstdint>
	#include <type_traits>
	// #include <cstddef>
	#include "./FileBuffer.zzh"
	#include "./Context.zzh"
#pragma endregion zzc
#pragma region zzc src_decl
	#include <string.h>
	#include <iostream>
	#include "./DecodeScan.zzh"
	#include "./Huffman.zzh"
	#include "../Markers.zzh"
#pragma endregion zzc


namespace BJpeg {
	namespace Decode {
		DECODE_FUN(image) {
			// printf("a\n");
			u32 result;
			ASSERT_MARKER(Marker :: SOI);
			CALL_DECODE(misc);
			if (file[index + 1] == Marker :: DHP) { CALL_DECODE(hierarchical); }
			else { CALL_DECODE(frame); }
			ASSERT_MARKER(Marker :: EOI);
			return DECODE_RESULT_OK;
		}
		
		namespace {
			DECODE_FUN(misc) {
				// while (true) { // actually, while has something to read
				for (int i = 0; i < 100; ++i) { // actually, while has something to read
					if (DECODE_READ_U8 != 0xFF) { return DECODE_RESULT_ERR; }
					u8 m = DECODE_READ_U8;
					u16 segment_length; DECODE_READ_U16(segment_length);
					switch (m) {
						case Marker :: DHT: {
							auto end = index + segment_length - 2;
							while (index < end) {
								u8 table_class, table_dest; DECODE_READ_U4(table_class, table_dest);
								if (table_class > 1 || table_dest > 3) { return DECODE_RESULT_ERR; }
								HuffmanTree& huffman = context.huffman_tree[table_class][table_dest];
								huffman.reset();
								u16 last_assigned_index = 0;
								u32 const counts_start = index - 1; // because of 1-indexing
								u32 const values_start = index + 16;
								u16 code = 0;
								u8 value_index = 0;
								u8 last_length = 1;
								u32 last_code  = 0;
								for (u8 length = 1; length <= 16; ++length) {
									u8 const count = file[counts_start + length];
									for (u8 i = 0; i < count; ++i) {
										u8 value = file[values_start + value_index];
										huffman.update(code, length, value, last_assigned_index);
										
										++code;
										++value_index;
										
										last_code = code;
										last_length = length;
									}
									code <<= 1;
								}
								if (last_code + 1 != 1 << last_length) {
									return DECODE_RESULT_ERR;
								}
								huffman.setLastNode(last_length);
								index = values_start + value_index;
							}
							if (!context.updateHuffmanCL()) { return DECODE_RESULT_ERR; }
						} break;
						case Marker :: DAC: {
							// not implemented
							index += segment_length - 2;
						} break;
						case Marker :: DQT: {
							for (u32 end = index - 2 + segment_length; index < end; ) {
								u8 Pq, Tq; DECODE_READ_U4(Pq, Tq);
								if (Tq > 3) { return DECODE_RESULT_ERR; }
								u16* table = &context.quantization_table[Tq][0][0];
								// or just memcpy + index update // but not actually (it complicates things, but is done once per image (not worth it))
								if (Pq == 0) { for (u8 i = 0; i < 64; ++i) { table[i] = DECODE_READ_U8; } } 
								else         { for (u8 i = 0; i < 64; ++i) { DECODE_READ_U16(table[i]); } }
							}
							if (!context.updateQTableCL()) { return DECODE_RESULT_ERR; }
						} break;
						case Marker :: DRI: {
							DECODE_READ_U16(context.restart_interval);
						} break;
						case Marker :: COM: { index += segment_length - 2; } break;
						default: {
							if (Marker :: isAPP(m)) {
								index += segment_length - 2;
							} else {
								// not a misc marker
								index -= 4;
								return DECODE_RESULT_OK;
							}
						} break;
					}
				}
				return DECODE_RESULT_OK;
			}
			DECODE_FUN(hierarchical) {
				std :: cerr << "Hierarchical mode not supported\n";
				// TODO if enabled, refactor frame (see [564678324])
				return DECODE_RESULT_ERR;
				u32 result;
				ASSERT_MARKER(Marker :: DHP);
				u16 Lf; DECODE_READ_U16(Lf);
				context.precision = DECODE_READ_U8;
				DECODE_READ_U16(context.Y);
				DECODE_READ_U16(context.X);
				u8 Nf = DECODE_READ_U8;
				for (u8 i = 0; i < Nf; ++i) {
					u8 C = DECODE_READ_U8;
					u8 H, V; DECODE_READ_U4(H, V);
					u8 Tq = DECODE_READ_U8;
				}
				while (true) {
					CALL_DECODE(misc);
					if (CHECK_MARKER(Marker :: EXP)) {
						u16 Le; DECODE_READ_U16(Le);
						u8 Eh, Ev; DECODE_READ_U4(Eh, Ev);
					}
					TRY_CALL_DECODE(frame) else { return DECODE_RESULT_OK; }
				}
			}
			DECODE_FUN(frame) {
				u32 result;
				if (DECODE_READ_U8 != 0xFF) { return DECODE_RESULT_ERR; }
				// TODO
				u8 marker = DECODE_READ_U8;
				if (!Marker :: isSOF(marker)) { return DECODE_RESULT_ERR; }
				context.sof_data = Marker :: SOFData(marker);
				u16 Lf; DECODE_READ_U16(Lf);
				context.precision = DECODE_READ_U8;
				DECODE_READ_U16(context.Y);
				DECODE_READ_U16(context.X);
				// TODO [564678324] this doesn't support multiple frames
				// which is fine if we don't support hierarchical
				u8 Nf = DECODE_READ_U8;
				if (Nf >= MAX_COMPONENTS) { 
					std :: cerr << "Not supported more than " << MAX_COMPONENTS << " components: " << Nf << "\n";
					return DECODE_RESULT_ERR;
				}
				context.component_count = Nf;
				context.size.file_size = file.length;
				context.size.y_mayor = context.Y;
				context.size.x_mayor = context.X;
				context.size.y_minor = ROUND_UP_8(context.Y) / 8;
				context.size.x_minor = ROUND_UP_8(context.X) / 8;
				if (!context.initBuffers1()) { return DECODE_RESULT_ERR; }
				defer { context.finishBuffers1(); };
				//	if (!context.cl.initBuffers(file.length, ROUND_UP_8(context.X) * ROUND_UP_8(context.Y) / 64)) { return DECODE_RESULT_ERR; }
				for (u8 i = 0; i < Nf; ++i) {
					u8 C = DECODE_READ_U8;
					if (C >= MAX_COMPONENTS) {
						std :: cerr << "Not supported more than " << MAX_COMPONENTS << " components: c=" << C << "\n";
						return DECODE_RESULT_ERR;
					}
					auto& component_data = context.component_data[C];
					DECODE_READ_U4(component_data.sampling_factor_x, component_data.sampling_factor_y);
					component_data.quantization_table = DECODE_READ_U8;
				}
				CALL_DECODE(misc);
				CALL_DECODE(scan); // at least 1 scan
				// DNL
				if (CHECK_MARKER(Marker :: DNL)) {
					std :: cerr << "DNL not supported\n";
					return DECODE_RESULT_ERR;
					u16 Ld; DECODE_READ_U16(Ld);
					u16 NL; DECODE_READ_U16(NL);
				}
				while (true) {
					CALL_DECODE(misc);
					TRY_CALL_DECODE(scan) else { return DECODE_RESULT_OK; }
				}
			}
		}
	}
}