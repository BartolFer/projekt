#include <iostream>
#include <cstdint>
#include "./Util.zzh"
#include "./Test.zzh"
#include "./Decode/FileBuffer.zzh"
#include "./Decode/Context.zzh"
#include "./Decode/Decoder.zzh"
#include "./Encode/Encoder.zzh"
#include "./MetaData.zzh"

namespace BJpeg {
	u8 recomended_space_pow = 26; // 64 MiB
		// note that this is not the actual space requirement
		// this is just a value that is used in a lot of buffers
}

#if defined TESTING || defined MAIN_TARGET_DECODE || defined MAIN_TARGET_ENCODE
	fun int main(int argc, char* argv[]) {
		#ifdef TESTING
			if (!BJpeg :: Test :: runTests()) { return EXIT_FAILURE; }
		#endif
		
		#ifdef MAIN_TARGET_DECODE
			return mainDecode(argc, argv);
		#endif
		#ifdef MAIN_TARGET_ENCODE
			return mainEncode(argc, argv);
		#endif
	}
#endif

#if defined MAIN_TARGET_DECODE || defined MAIN_TARGET_ENCODE
	
	fun int mainDecode(int argc, char* argv[]) {
		if (argc > 3) {
			printf("Usage: <exe> path/to/file.jpg path/to/output.rgba\n");
			exit(EXIT_FAILURE);
		}
		std :: string path      = argc >= 2 ? argv[1] : "D:/Personal/nastava/projekt/Temp/Zugpsitze_mountain.jpg";
		char const* output_path = argc >= 3 ? argv[2] : "D:/Personal/nastava/projekt/Temp/output.rgba";
		
		using namespace BJpeg;
		
		Resource<Decode :: InputFileBuffer> file(path);
		if (!file   ) { std :: cerr << "!file"    << std :: endl; return 1; }
		Resource<Decode :: Context> context;
		if (!context) { std :: cerr << "!context" << std :: endl; return 1; }
		
		auto res = Decode :: image(context, file, 0);
		std :: cout << "res = " << res << std :: endl;
		
		if (res == DECODE_RESULT_ERR) { return EXIT_FAILURE; }
		if (res != file.length) { return EXIT_FAILURE; }
		
		MetaData metadata = { .width = (int) context.size.x_mayor, .height = (int) context.size.y_mayor, .n_channels = 4 };
		size_t total_pixels = metadata.height * metadata.width;
		RGBA* arr = new RGBA[total_pixels];
		if (!context.cl.buffer.image.read(context.cl.queue, arr)) { clog("Failed to read result image buffer"); return EXIT_FAILURE; }
		
		FILE* output = fopen(output_path, "wb");
		if (output == nullptr) { clog("Failed to open output file %s", output_path); return EXIT_FAILURE; }
		defer { fclose(output); };
		fwrite(&metadata, sizeof(metadata), 1, output);
		fwrite(arr, sizeof(RGBA), total_pixels, output);
		printf("Created file %s\n", output_path);
		
		return 0;
	}
	
	fun int mainEncode(int argc, char* argv[]) {
		if (argc > 5) {
			printf("Usage: <exe> path/to/file.rgba path/to/definitions/jpg path/to/output.jpg sampling_factors\n");
			exit(EXIT_FAILURE);
		}
		char const* path        = argc >= 2 ? argv[1] : "D:/Personal/nastava/projekt/Temp/output.rgba";
		std :: string def_path  = argc >= 3 ? argv[2] : "D:/Personal/nastava/projekt/Temp/Zugpsitze_mountain.def.jpg";
		char const* output_path = argc >= 4 ? argv[3] : "D:/Personal/nastava/projekt/Temp/Zugpsitze_mountain.out.jpg";
		char const* sfs         = argc >= 5 ? argv[4] : "111";
		
		using namespace BJpeg;
		
		FILE* file_rgba = fopen(path, "rb");
		if (!file_rgba) { printf("Failed to open file %s\n", path); }
		defer { fclose(file_rgba); };
		
		MetaData metadata;
		if (fread(&metadata, sizeof(metadata), 1, file_rgba) != 1) {
			printf("Failed to read metadata from file %s\n", path);
			return EXIT_FAILURE;
		}
		size_t total_pixels = metadata.height * metadata.width;
		RGBA* arr = new RGBA[total_pixels];
		if (fread(arr, sizeof(RGBA), total_pixels, file_rgba) != total_pixels) {
			printf("Failed to read image data from file %s\n", path);
			return EXIT_FAILURE;
		}
		
		Resource<Encode :: CLContext> cl;
		Resource<MyOpenCL :: Buffer<RGBA>> image(cl.context, /* CL_MEM_HOST_WRITE_ONLY | */ CL_MEM_READ_ONLY, total_pixels);
		if (!image) { std :: cerr << "!image" << std :: endl; return EXIT_FAILURE; }
		if (!image.write(cl.queue, arr)) { std :: cerr << "!image.write" << std :: endl; return EXIT_FAILURE; }
		
		QuantizationTable qtables[4];
		Encode :: HuffmanTable htables[2][4];
		
		if (!Encode :: ReadJpegDef(def_path, qtables, htables)) {
			std :: cerr << "Failed to read JPEG definitions from " << def_path << std :: endl;
			return EXIT_FAILURE;
		}
		
		//	SamplingFactor sampling_factors[MAX_COMPONENTS] = {{ 1, 1 }, { 2, 2 }, { 2, 2 }};
		SamplingFactor sampling_factors[MAX_COMPONENTS] = {{ 1, 1 }, { 1, 1 }, { 1, 1 }};
		if (!parseSF(sfs, sampling_factors)) { std :: cerr << "invalid SF" << std :: endl;  return EXIT_FAILURE; }
		
		auto res = Encode :: image(image, cl, metadata.height, metadata.width, qtables, htables, sampling_factors);
		std :: cout << "res len = " << res.length << std :: endl;
		if (!res) { return EXIT_FAILURE; }
		defer { res.finish(); };
		
		FILE* output = fopen(output_path, "wb");
		if (output == nullptr) { clog("Failed to open output file %s", output_path); return EXIT_FAILURE; }
		defer { fclose(output); };
		fwrite(res.array, sizeof(res[0]), res.length, output);
		printf("Created file %s\n", output_path);
		
		return 0;
	}
	fun bool parseSF(char const* arg, BJpeg :: SamplingFactor sampling_factors[]) {
		int acc = 0;
		for (int i = 0; i < 3; ++i) {
			if (!('0' <= arg[i] && arg[i] <= '9')) { clog("bbx 0 %d %c", arg[i], arg[i]); return false; }
			sampling_factors[i].y = sampling_factors[i].x = arg[i] - '0';
			acc += sampling_factors[i].y * sampling_factors[i].x;
		}
		if (acc > MAX_MCU_LENGTH) { clog("bbx 1 %d", acc); return false; }
		if (arg[3] != '\0') { clog("bbx 2 %d %c", arg[3], arg[3]); return false; }
		return true;
	}
	
#endif
