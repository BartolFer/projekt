#ifndef VSCODE_ONLY
	#hdr
		#pragma once
		#include <cstdint>
		#include "./Huffman.hpp"
		#include "./Markers.hpp"
		#include "./Util.hpp"
		#include "./MyOpenCL.hpp"
	#end
	#src
		#include "./kernels.cl.hpp"
		#include <bit>
	#end
#else // if VSCODE
	#include <cstdint>
	#include "./Context.hpp"
	#include "./Huffman.hpp"
	#include "./Markers.hpp"
	#include "./Util.hpp"
	#include "./MyOpenCL.hpp"
	#include "./kernels.cl.hpp"
	#include <bit>
#endif

namespace BJpeg {
	typedef uint16_t QuantizationTable[64];
	struct ComponentData {
		// commputation
		uint16_t predictor;
		// from frame header
		uint8_t sampling_factor_x;
		uint8_t sampling_factor_y;
		uint8_t quantization_table;
		// from scan header
		uint8_t dc_entropy_table;
		uint8_t ac_entropy_table;
		uint8_t _padding;
	};
	
	struct LaneInfo {
		u8 c_id;
		u8 dc_huf;
		u8 ac_huf;
		u8 y;
		u8 x;
		u8 _6;
		u8 _7;
		u8 _8;
	};
	template <CodingType CODING_TYPE>
	struct CLContext;
	template <>
	struct CLContext<CodingType :: DECODE> {
		MyOpenCL :: Context context            ;
		MyOpenCL :: Queue   queue              ;
		MyOpenCL :: Program program            ;
		struct Kernels {
			MyOpenCL :: Kernel decodeHuffman1     ; enum      decodeHuffman1Args { payload, B2, trees, lane_infos, lanes, lane_width, lane_indexes, };
			MyOpenCL :: Kernel decodeRaise        ; enum         decodeRaiseArgs { lanes, lane_width, lanes_count, prev_size_pow, };
			MyOpenCL :: Kernel decodeLower        ; enum         decodeLowerArgs { positions, lanes, lane_width, lanes_count, size_pow, };
			MyOpenCL :: Kernel positionsToIndexes ; enum  positionsToIndexesArgs { positions, indexes, lane_width, };
			MyOpenCL :: Kernel decodeHuffman2     ; enum      decodeHuffman2Args { payload, trees, lane_infos, lane_width, indexes, coefficients, };
			MyOpenCL :: Kernel initializeBufferU32; enum initializeBufferU32Args { buffer, value, };
		};
		Kernels kernel;
		struct Buffers {
			MyOpenCL :: Buffer<u8> payload;
			MyOpenCL :: Buffer<HuffmanTree<CodingType :: DECODE>[4]> trees;
			MyOpenCL :: Buffer<LaneInfo> lane_infos;
			MyOpenCL :: Buffer<u32> lanes;
			MyOpenCL :: Buffer<u8> lane_indexes;
			MyOpenCL :: Buffer<u32> positions;
			MyOpenCL :: Buffer<u32x2> indexes;
			MyOpenCL :: Buffer<i16[64]> coefficients;
		};
		Buffers buffer;
		bool initialized;
		
		size_t img_size;
		size_t lane;
		size_t row;
		size_t lanes;

		CLContext() : initialized(false) {}
		
		bool init(size_t file_size, size_t img_dimensions) {
			// TODO maybe return true to allow multiple initializations
			if (initialized) { return false; }
			size_t img_size = self.img_size  = MAX_COMPONENTS * img_dimensions;
			size_t lane     = self.lane      = 8 * file_size;
			size_t row      = self.row       = 10 * lane;
			size_t lanes    = self.lanes     = row * std :: bit_width(img_size);
			
			cl_device_id device_id;
			if (!MyOpenCL :: getDeviceId(device_id)) { return false; }
			if (!self.context.init(device_id)) { return false; }
			if (!self.queue  .init(device_id, self.context)) { return false; }
			if (!self.program.init(device_id, self.context, kernels)) { return false; }
			
			if (!self.kernel.decodeHuffman1     .init(self.program, "decodeHuffman1"     )) { return false; }
			if (!self.kernel.decodeRaise        .init(self.program, "decodeRaise"        )) { return false; }
			if (!self.kernel.decodeLower        .init(self.program, "decodeLower"        )) { return false; }
			if (!self.kernel.positionsToIndexes .init(self.program, "positionsToIndexes" )) { return false; }
			if (!self.kernel.decodeHuffman2     .init(self.program, "decodeHuffman2"     )) { return false; }
			if (!self.kernel.initializeBufferU32.init(self.program, "initializeBufferU32")) { return false; }
			
			if (!self.buffer.payload     .init(self.context, CL_MEM_HOST_WRITE_ONLY | CL_MEM_READ_ONLY , file_size     )) { return false; }
			if (!self.buffer.trees       .init(self.context, CL_MEM_HOST_WRITE_ONLY | CL_MEM_READ_ONLY , 2             )) { return false; }
			if (!self.buffer.lane_infos  .init(self.context, CL_MEM_HOST_WRITE_ONLY | CL_MEM_READ_ONLY , MAX_LANE_COUNT)) { return false; }
			if (!self.buffer.lanes       .init(self.context, CL_MEM_HOST_READ_ONLY  | CL_MEM_READ_WRITE, lanes         )) { return false; }
			if (!self.buffer.lane_indexes.init(self.context, CL_MEM_HOST_WRITE_ONLY | CL_MEM_READ_ONLY , MAX_COMPONENTS)) { return false; }
			if (!self.buffer.positions   .init(self.context, CL_MEM_HOST_WRITE_ONLY | CL_MEM_READ_WRITE, row           )) { return false; }
			if (!self.buffer.indexes     .init(self.context, CL_MEM_HOST_NO_ACCESS  | CL_MEM_READ_WRITE, img_size      )) { return false; }
			if (!self.buffer.coefficients.init(self.context, CL_MEM_HOST_READ_ONLY  | CL_MEM_WRITE_ONLY, img_size      )) { return false; }
			
			if (!self.kernel.decodeHuffman1.setArg(self.buffer.payload     , Kernels :: decodeHuffman1Args :: payload     )) { return false; }
			if (!self.kernel.decodeHuffman1.setArg(self.buffer.trees       , Kernels :: decodeHuffman1Args :: trees       )) { return false; }
			if (!self.kernel.decodeHuffman1.setArg(self.buffer.lane_infos  , Kernels :: decodeHuffman1Args :: lane_infos  )) { return false; }
			if (!self.kernel.decodeHuffman1.setArg(self.buffer.lanes       , Kernels :: decodeHuffman1Args :: lanes       )) { return false; }
			if (!self.kernel.decodeHuffman1.setArg(self.buffer.lane_indexes, Kernels :: decodeHuffman1Args :: lane_indexes)) { return false; }
			
			if (!self.kernel.decodeRaise.setArg(self.buffer.lanes, Kernels :: decodeRaiseArgs :: lanes)) { return false; }
			
			if (!self.kernel.decodeLower.setArg(self.buffer.positions, Kernels :: decodeLowerArgs :: positions)) { return false; }
			if (!self.kernel.decodeLower.setArg(self.buffer.lanes    , Kernels :: decodeLowerArgs :: lanes    )) { return false; }
			
			if (!self.kernel.positionsToIndexes.setArg(self.buffer.positions, Kernels :: positionsToIndexesArgs :: positions)) { return false; }
			if (!self.kernel.positionsToIndexes.setArg(self.buffer.indexes  , Kernels :: positionsToIndexesArgs :: indexes  )) { return false; }
			
			if (!self.kernel.decodeHuffman2.setArg(self.buffer.payload     , Kernels :: decodeHuffman2Args :: payload     )) { return false; }
			if (!self.kernel.decodeHuffman2.setArg(self.buffer.trees       , Kernels :: decodeHuffman2Args :: trees       )) { return false; }
			if (!self.kernel.decodeHuffman2.setArg(self.buffer.lane_infos  , Kernels :: decodeHuffman2Args :: lane_infos  )) { return false; }
			if (!self.kernel.decodeHuffman2.setArg(self.buffer.indexes     , Kernels :: decodeHuffman2Args :: indexes     )) { return false; }
			if (!self.kernel.decodeHuffman2.setArg(self.buffer.coefficients, Kernels :: decodeHuffman2Args :: coefficients)) { return false; }
			
			self.initialized = true;
			return true;
		}
		void finish() {
			self.context.finish();
			self.queue  .finish();
			self.program.finish();
			self.kernel.decodeHuffman1     .finish();
			self.kernel.decodeRaise        .finish();
			self.kernel.decodeLower        .finish();
			self.kernel.positionsToIndexes .finish();
			self.kernel.decodeHuffman2     .finish();
			self.kernel.initializeBufferU32.finish();
			self.buffer.payload     .finish();
			self.buffer.trees       .finish();
			self.buffer.lane_infos  .finish();
			self.buffer.lanes       .finish();
			self.buffer.lane_indexes.finish();
			self.buffer.positions   .finish();
			self.buffer.indexes     .finish();
			self.buffer.coefficients.finish();
		}
	};

	template <CodingType CODING_TYPE>
	struct Context {};
	template <> struct Context<DECODE> {
		Marker :: SOFData sof_data;
		uint16_t restart_interval;
		u8 component_count;
		uint8_t precision;
		uint16_t X, Y;
		ComponentData component_data[MAX_COMPONENTS];
		CLContext<DECODE> cl;
		HuffmanTree<DECODE> huffman_tree[2][4];
		QuantizationTable quantization_table[4];
		u8* payload;
		
		
		bool init() {
			self.restart_interval = 0;
			self.precision = 8;
			if (!(self.payload = new u8[RECOMMENDED_SPACE])) {
				return false;
			}
			
			return true;
		}
		void finish() {
			delete[] self.payload;
			self.cl.finish();
		}
		
		bool updatePayload(u8 payload[], size_t length) {
			if (!self.cl.buffer.payload.write(self.cl.queue, payload, length)) { return false; }
			return true;
		}
		bool updateHuffmanCL() {
			if (!self.cl.buffer.trees.write(self.cl.queue, self.huffman_tree)) { return false; }
			return true;
		}
		bool updateLaneInfos(LaneInfo lane_infos[MAX_LANE_COUNT]) {
			if (!self.cl.buffer.lane_infos.write(self.cl.queue, lane_infos)) { return false; }
			return true;
		}
		bool updateLaneIndexes(u8 lane_indexes[MAX_COMPONENTS]) {
			if (!self.cl.buffer.lane_indexes.write(self.cl.queue, lane_indexes)) { return false; }
			return true;
		}
	};
	
	typedef Context<CodingType :: DECODE> DecodeContext;
	typedef Context<CodingType :: ENCODE> EncodeContext;
}