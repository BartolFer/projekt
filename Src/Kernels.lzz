#ifndef VSCODE_ONLY
	#hdr
		#pragma once
		#include <cstdint>
		#include "./Huffman.hpp"
		#include "./Markers.hpp"
		#include "./Util.hpp"
		#include "./MyOpenCL.hpp"
	#end
	#src
		#include "./kernels.cl.hpp"
		#include <bit>
	#end
#else // if VSCODE
	#include <cstdint>
	#include "./Kernels.hpp"
	#include "./Huffman.hpp"
	#include "./Markers.hpp"
	#include "./Util.hpp"
	#include "./MyOpenCL.hpp"
	#include "./kernels.cl.hpp"
	#include <bit>
#endif

namespace BJpeg {
	struct LaneInfo {
		u8 c_id;
		u8 dc_huf;
		u8 ac_huf;
		u8 y;
		u8 x;
		u8 start_in_mcu;
		u8 amount_in_mcu;
		u8 _8;
	};

	struct Kernels {
		typedef MyOpenCL :: Buffer<HuffmanTree<CodingType :: DECODE>[4]> HuffmanBuf;
		struct decodeHuffman1 : MyOpenCL :: Kernel<2> {
			bool init(MyOpenCL :: Program program) { return static_cast<MyOpenCL :: Kernel<2>>(self).init(program, "decodeHuffman1"); }
			bool setArg_payload           (MyOpenCL :: Buffer<u8>          x) { return self.setArg(x, 0); }
			bool setArg_B2                (u32                             x) { return self.setArg(x, 1); }
			bool setArg_trees             (HuffmanBuf                      x) { return self.setArg(x, 2); }
			bool setArg_lane_infos        (MyOpenCL :: Buffer<LaneInfo>    x) { return self.setArg(x, 3); }
			bool setArg_lanes             (MyOpenCL :: Buffer<u32>         x) { return self.setArg(x, 4); }
			bool setArg_lane_width        (u32                             x) { return self.setArg(x, 5); }
			bool setArg_lane_indexes      (MyOpenCL :: Buffer<u8>          x) { return self.setArg(x, 6); }
		};
		struct decodeHuffman1 decodeHuffman1;
		
		struct decodeRaise : MyOpenCL :: Kernel<2> {
			bool init(MyOpenCL :: Program program) { return static_cast<MyOpenCL :: Kernel<2>>(self).init(program, "decodeRaise"); }
			bool setArg_lanes             (MyOpenCL :: Buffer<u32>         x) { return self.setArg(x, 0); }
			bool setArg_lane_width        (u32                             x) { return self.setArg(x, 1); }
			bool setArg_lanes_count       (u8                              x) { return self.setArg(x, 2); }
			bool setArg_prev_size_pow     (u8                              x) { return self.setArg(x, 3); }
		};
		struct decodeRaise decodeRaise;
		
		struct decodeLower : MyOpenCL :: Kernel<2> {
			bool init(MyOpenCL :: Program program) { return static_cast<MyOpenCL :: Kernel<2>>(self).init(program, "decodeLower"); }
			bool setArg_positions         (MyOpenCL :: Buffer<u32>         x) { return self.setArg(x, 0); }
			bool setArg_lanes             (MyOpenCL :: Buffer<u32>         x) { return self.setArg(x, 1); }
			bool setArg_lane_width        (u32                             x) { return self.setArg(x, 2); }
			bool setArg_lanes_count       (u8                              x) { return self.setArg(x, 3); }
			bool setArg_size_pow          (u8                              x) { return self.setArg(x, 4); }
		};
		struct decodeLower decodeLower;
		
		struct positionsToIndexes : MyOpenCL :: Kernel<2> {
			bool init(MyOpenCL :: Program program) { return static_cast<MyOpenCL :: Kernel<2>>(self).init(program, "positionsToIndexes"); }
			bool setArg_positions         (MyOpenCL :: Buffer<u32>         x) { return self.setArg(x, 0); }
			bool setArg_indexes           (MyOpenCL :: Buffer<u32x2>       x) { return self.setArg(x, 1); }
			bool setArg_lane_width        (u32                             x) { return self.setArg(x, 2); }
		};
		struct positionsToIndexes positionsToIndexes;
		
		struct decodeHuffman2 : MyOpenCL :: Kernel<1> {
			bool init(MyOpenCL :: Program program) { return static_cast<MyOpenCL :: Kernel<1>>(self).init(program, "decodeHuffman2"); }
			bool setArg_payload           (MyOpenCL :: Buffer<u8>          x) { return self.setArg(x, 0); }
			bool setArg_trees             (HuffmanBuf                      x) { return self.setArg(x, 1); }
			bool setArg_lane_infos        (MyOpenCL :: Buffer<LaneInfo>    x) { return self.setArg(x, 2); }
			bool setArg_lane_width        (u32                             x) { return self.setArg(x, 3); }
			bool setArg_indexes           (MyOpenCL :: Buffer<u32x2>       x) { return self.setArg(x, 4); }
			bool setArg_coefficients      (MyOpenCL :: Buffer<i16[64]>     x) { return self.setArg(x, 5); }
		};
		struct decodeHuffman2 decodeHuffman2;
		
		struct initializeBufferU32 : MyOpenCL :: Kernel<1> {
			bool init(MyOpenCL :: Program program) { return static_cast<MyOpenCL :: Kernel<1>>(self).init(program, "initializeBufferU32"); }
			bool setArg_buffer            (MyOpenCL :: Buffer<u32>         x) { return self.setArg(x, 0); }
			bool setArg_value             (u32                             x) { return self.setArg(x, 1); }
		};
		struct initializeBufferU32 initializeBufferU32;
		
		struct prepareMCUs : MyOpenCL :: Kernel<2> {
			bool init(MyOpenCL :: Program program) { return static_cast<MyOpenCL :: Kernel<2>>(self).init(program, "prepareMCUs"); }
			bool setArg_coefficients      (MyOpenCL :: Buffer<i16[64]>     x) { return self.setArg(x, 0); }
			bool setArg_lane_infos        (MyOpenCL :: Buffer<LaneInfo>    x) { return self.setArg(x, 1); }
			bool setArg_mcu_length        (u8                              x) { return self.setArg(x, 2); }
		};
		struct prepareMCUs prepareMCUs;
		
		struct prefixSum1 : MyOpenCL :: Kernel<1> {
			bool init(MyOpenCL :: Program program) { return static_cast<MyOpenCL :: Kernel<1>>(self).init(program, "prefixSum1"); }
			bool setArg_coefficients      (MyOpenCL :: Buffer<i16[64]>     x) { return self.setArg(x, 0); }
			bool setArg_lane_infos        (MyOpenCL :: Buffer<LaneInfo>    x) { return self.setArg(x, 1); }
			bool setArg_half_size         (u32                             x) { return self.setArg(x, 2); }
			bool setArg_mcu_length        (u8                              x) { return self.setArg(x, 3); }
		};
		struct prefixSum1 prefixSum1;
		
		struct prefixSum2 : MyOpenCL :: Kernel<1> {
			bool init(MyOpenCL :: Program program) { return static_cast<MyOpenCL :: Kernel<1>>(self).init(program, "prefixSum2"); }
			bool setArg_coefficients      (MyOpenCL :: Buffer<i16[64]>     x) { return self.setArg(x, 0); }
			bool setArg_lane_infos        (MyOpenCL :: Buffer<LaneInfo>    x) { return self.setArg(x, 1); }
			bool setArg_half_size         (u32                             x) { return self.setArg(x, 2); }
			bool setArg_mcu_length        (u8                              x) { return self.setArg(x, 3); }
		};
		struct prefixSum2 prefixSum2;
		
		struct unzigzag_quantization_dct : MyOpenCL :: Kernel<1> {
			bool init(MyOpenCL :: Program program) { return static_cast<MyOpenCL :: Kernel<1>>(self).init(program, "unzigzag_quantization_dct"); }
			bool setArg_coefficients      (MyOpenCL :: Buffer<i16[64]>     x) { return self.setArg(x, 0); }
			bool setArg_quantization_table(MyOpenCL :: Buffer<i16[64]>     x) { return self.setArg(x, 1); }
			bool setArg_lane_infos        (MyOpenCL :: Buffer<LaneInfo>    x) { return self.setArg(x, 2); }
			bool setArg_mcu_length        (u8                              x) { return self.setArg(x, 3); }
		};
		struct unzigzag_quantization_dct unzigzag_quantization_dct;
		
		struct uninterleave_upsample : MyOpenCL :: Kernel<2> {
			bool init(MyOpenCL :: Program program) { return static_cast<MyOpenCL :: Kernel<2>>(self).init(program, "uninterleave_upsample"); }
			bool setArg_coefficients      (MyOpenCL :: Buffer<i16[64]>     x) { return self.setArg(x, 0); }
			bool setArg_lane_infos        (MyOpenCL :: Buffer<LaneInfo>    x) { return self.setArg(x, 1); }
			bool setArg_half_size         (u32                             x) { return self.setArg(x, 2); }
			bool setArg_mcu_length        (u8                              x) { return self.setArg(x, 3); }
		};
		struct uninterleave_upsample uninterleave_upsample;
	};
}
