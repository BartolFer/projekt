#include <bitset>

#include "../Util.zzh"
#include "../JpegTypes.zzh"
#include "../Markers.zzh"
#include "../MyOpenCL.zzh"
#include "./Huffman.zzh"
#include "./ClContext.zzh"
#include "../Decode/FileBuffer.zzh"

#pragma region zzc src_decl
	#define full_step (2 * half_step)
#pragma endregion zzc

namespace BJpeg {
	namespace Encode {
		fun ArrayWithLength<u8> image(MyOpenCL :: Buffer<RGBA> image, CLContext cl, size_t height, size_t width, QuantizationTable qtables[4], HuffmanTable htables[2][4], SamplingFactor sampling_factors[MAX_COMPONENTS]) {
			//	we will assume image has 3 components
			//	There are 2 qtables and 4 htables: 
			//		C1 has qtables[0] and both htables[DC/AC][0]
			//		C2 & C3 share qtables[1] and both htables[DC/AC][1]
			
			LaneInfo lane_infos[MAX_MCU_LENGTH]; LaneInfo* lane_infos_ptr = lane_infos;
			u8 max_sf_y = 1;
			u8 max_sf_x = 1;
			u8 mcu_length = 0;
			for (u8 i = 0; i < 3; ++i) {
				auto sf = sampling_factors[i];
				if (sf.y > max_sf_y) { max_sf_y = sf.y; }
				if (sf.x > max_sf_x) { max_sf_x = sf.x; }
				mcu_length += sf.y * sf.x;
				for (int y = 0; y < sf.y; ++y) {
					for (int x = 0; x < sf.x; ++x) {
						lane_infos_ptr++->c_id = i + 1;
					}
				}
				lane_infos[i].sf_y = sf.y;
				lane_infos[i].sf_x = sf.x;
			}
			lane_infos[0].hvalues_step = lane_infos[0].sf_y * lane_infos[0].sf_x;
			lane_infos[1].hvalues_step = lane_infos[1].sf_y * lane_infos[1].sf_x + lane_infos[2].sf_y * lane_infos[2].sf_x;
			u8x2 max_sf = { max_sf_x, max_sf_y };
			size_t mcu_y = ROUND_UP_8(height) / 8 / max_sf_y;
			size_t mcu_x = ROUND_UP_8(width ) / 8 / max_sf_x;
			size_t mcu_count = mcu_x * mcu_y;
			size_t unit_count = mcu_count * mcu_length;
			clog("max_sf_y = %d", max_sf_y);
			clog("max_sf_x = %d", max_sf_x);
			clog("mcu_length = %d", mcu_length);
			clog("mcu_y = %d", mcu_y);
			clog("mcu_x = %d", mcu_x);
			clog("mcu_count = %d", mcu_count);
			clog("unit_count = %d", unit_count);
			
			if (!cl.buffer.htables   .write(cl.queue, htables   )) { return {}; }
			if (!cl.buffer.qtables   .write(cl.queue, qtables   )) { return {}; }
			if (!cl.buffer.lane_infos.write(cl.queue, lane_infos)) { return {}; }
			
			size_t dc_count_0 = mcu_count *  sampling_factors[0].y * sampling_factors[0].x;
			size_t dc_count_1 = mcu_count * (sampling_factors[1].y * sampling_factors[1].x + sampling_factors[2].y * sampling_factors[2].x);
			
			if (!cl.initBuffers1(height, width, unit_count, max_sf, mcu_length, dc_count_0, dc_count_1)) { return {}; }
			defer { cl.finishBuffers1(); };
			
			if (!cl.kernel.RGB_to_YCbCr.setArg_image(image)) { return {}; }
			if (!cl.kernel.RGB_to_YCbCr.call(cl.queue, { height, width })) { return {}; }
			
			//	TODO fill missing in both de & en
			if (!cl.kernel.interleave_downsample.call(cl.queue, { mcu_y, mcu_x })) { return {}; }
			
			if (!cl.kernel.dct_quantization_zigzag.call(cl.queue, { mcu_count, mcu_length })) { return {}; }
			
			//	debugPrintCoefficients(cl);
			//	FI fi0; if (!cl.buffer.coefficients.read(cl.queue, &fi0, 0, 0, 1, 0)) { return {}; } clog("fi = %d or %f", fi0.i, fi0.f);
			if (!cl.kernel.deltaDC1.call(cl.queue, { mcu_count })) { return {}; }
			if (!cl.kernel.deltaDC2.call(cl.queue, { unit_count })) { return {}; }
			//	debugPrintCoefficients(cl);
			
			{ //	generate Huffman
				if (!cl.kernel.initCounts         .call(cl.queue, { 4, 256 })) { return {}; }
				//	if (!cl.buffer.hvalues_dc_0.debugWrite(cl.queue, 1)) { return {}; }
				if (!cl.kernel.gatherHuffmanValues.call(cl.queue, { mcu_count })) { return {}; }
				//	if (!cl.buffer.hvalues_dc_0.debugWrite(cl.queue, 1)) { return {}; }
				//	debugPrintCoefficients(cl);
				//	FI fi0; if (!cl.buffer.coefficients.read(cl.queue, &fi0, 0, 0, 1, 0)) { return {}; } clog("fi = %d or %f", fi0.i, fi0.f);
				//	if (!cl.buffer.hvalues_dc_0.debugWrite(cl.queue)) { return {}; } clog();
				if (!countOccurances(cl, cl.buffer.hvalues_dc_0, dc_count_0     , 0b00)) { return {}; }
				//	if (!cl.buffer.hvalues_dc_0.debugWrite(cl.queue)) { return {}; } clog();
				
				
				//	u32 counts[4][256];
				//	if (!cl.buffer.counts.read(cl.queue, counts)) { return {}; }
				//	//	std :: cout << "[ "; for (u32 x : counts[0]) { if (x) std :: cout << x << ", "; else std :: cout << "." << ", "; } std :: cout << " ]" << std :: endl;
				if (!countOccurances(cl, cl.buffer.hvalues_dc_1, dc_count_1     , 0b01)) { return {}; }
				if (!countOccurances(cl, cl.buffer.hvalues_ac_0, dc_count_0 * 63, 0b10)) { return {}; }
				if (!countOccurances(cl, cl.buffer.hvalues_ac_1, dc_count_1 * 63, 0b11)) { return {}; }
				
				u32 counts[4][256];
				if (!cl.buffer.counts.read(cl.queue, counts)) { return {}; }
				//	std :: cout << "[ "; for (u32 x : counts[0]) { if (x) std :: cout << x << ", "; else std :: cout << "." << ", "; } std :: cout << " ]" << std :: endl;
				
				HuffmanEncoder :: generateTable(counts[0b00], htables[0][0]);
				//	std :: cout << "[ "; for (u32 x : counts[0]) { if (x) std :: cout << x << ", "; else std :: cout << "." << ", "; } std :: cout << " ]" << std :: endl;
				//	std :: cout << "[ "; for (auto [c, x] : htables[0][0]) { if (x) std :: cout << x << ", "; else std :: cout << "." << ", "; } std :: cout << " ]" << std :: endl;
				//	std :: cout << "[ "; for (u32 v = 0; v < 256; ++v) { auto [c, l] = htables[0][0][v]; if (l) std :: cout << v << ":" << l << " "; else std :: cout << "." << " "; } std :: cout << " ]" << std :: endl;
				HuffmanEncoder :: generateTable(counts[0b01], htables[0][1]);
				HuffmanEncoder :: generateTable(counts[0b10], htables[1][0]);
				HuffmanEncoder :: generateTable(counts[0b11], htables[1][1]);
				//	std :: cout << "[ "; for (auto [c, x] : htables[0][0]) { if (x) std :: cout << x << ", "; else std :: cout << "." << ", "; } std :: cout << " ]" << std :: endl;
				//	for (int cls = 0; cls < 2; ++cls) {
				//		for (int dst = 0; dst < 2; ++dst) {
				//			clog("Huffman %cC %d", cls?'A':'D', dst);
				//			for (int v = 0; v < 256; ++v) {
				//				auto [c, l] = htables[cls][dst][v];
				//				u8 RRRR = v >> 4, SSSS = v & 0x0F;
				//				if (l == 0) { continue; }
				//				clog("\t\t\t%u|%u/%u: %s", RRRR, SSSS, 1 << SSSS >> 1, toBin(c, l));
				//			}
				//		}
				//	}
				
				if (!cl.buffer.htables.write(cl.queue, htables)) { return {}; }
			}
			//	return { 1, new u8[1] };
			//	debugPrintCoefficients(cl);
			
			if (!cl.kernel.encodeHuffman.call(cl.queue, { mcu_count, mcu_length })) { return {}; }
			//	{
			//		cl.buffer.codes;
			//		u32      * lengths = new u32      [unit_count]; if (!lengths) { return {}; } defer { delete[] lengths; };
			//		CodedUnit* codes   = new CodedUnit[unit_count]; if (!codes  ) { return {}; } defer { delete[] codes  ; };
			//		if (!cl.buffer.lengths.read(cl.queue, lengths, unit_count, 1)) { return {}; }
			//		if (!cl.buffer.codes  .read(cl.queue, codes  , unit_count, 0)) { return {}; }
			//		for (int i = 0; i < unit_count; ++i) {
			//			u32 length = lengths[i];
			//			CodedUnit& code = codes[i];
			//			for (int i = 0; i < length / 32; ++i) {
			//				for (int j = 32; j-- > 0; ) {
			//					putchar(code[i] >> j & 1 ? '1' : '0');
			//				}
			//				putchar(' ');
			//			}
			//			for (int j = 32; j-- > 32 - length % 32; ) {
			//				putchar(code[length / 32] >> j & 1 ? '1' : '0');
			//			}
			//			putchar('\n');
			//		}
			//	}
			//	if (!cl.buffer.lengths.debugWrite(cl.queue, unit_count + 1, 0)) { return {}; }
			
			u32 total_size = prefixSumLengths(cl, unit_count, mcu_length);
			//	if (!cl.buffer.lengths.debugWrite(cl.queue, unit_count + 1, 0)) { return {}; }
			if (total_size == 0) { return {}; }
			size_t payload_size = ROUND_UP_8(total_size) / 8;
			if (!cl.initBuffers2(payload_size)) { return {}; }
			defer { cl.finishBuffers2(); };
			
			#define BJPEG_MAX_GLOBAL_WORK_HERE (((size_t)1U) << 13) //	8192
			size_t remaining_work = unit_count;
			size_t offset = 0;
			
			
			for (; remaining_work > BJPEG_MAX_GLOBAL_WORK_HERE; remaining_work -= BJPEG_MAX_GLOBAL_WORK_HERE, offset += BJPEG_MAX_GLOBAL_WORK_HERE) {
				if (!cl.kernel.concatCodes.call(cl.queue, { BJPEG_MAX_GLOBAL_WORK_HERE }, { offset })) { return {}; }
			}
			if (!cl.kernel.concatCodes.call(cl.queue, { remaining_work }, { offset })) { return {}; }
			
			u8* payload = new u8[payload_size];
			if (!payload) { std :: cerr << "Not enough RAM" << std :: endl; return {}; }
			defer { delete[] payload; };
			if (!cl.buffer.payload.read(cl.queue, payload, payload_size)) { return {}; }
			//	clog("01100101 10100111 10001011 10001101 01100111 01010001 11011011 00100101 10110110 01100001 10111000 00011100 01101000 01010100 10000000 00111001 00111110 00000110 11100110 00101011 00000100 00111010 01001010 01110100 00111110 11111010 10001010 11101001 00001110 11101000 11010111 10101110 00011011 10110101 01110110 10010010 10111010 01011110 00111110 01100010 11100001 01011111 00110110 11001011 11011110 10110110 00010011 00011000 10111100 10001000 00111110 10010000 11100101 01000111 11100010 00111110 10000101 10000100 00010101 00101101 10100000 10000100 00111010 01001010 01011101 1111010")
			//	clog();
			//	for (int i = 0; i < payload_size; ++i) {
			//		std :: cout << std :: bitset<8>(payload[i]) << " ";
			//	} std :: cout << std :: endl;
			
			size_t old_payload_size = payload_size;
			for (int i = 0; i < old_payload_size; ++i) {
				if (payload[i] == 0xFF) {
					++payload_size;
				}
			}
			clog("%u -> %u", old_payload_size, payload_size);
			
			ArrayWithLength<u8> result;
			u16 frame_header_size = 2 + 1 + 2 + 2 + 1 + 3 * (1 + 1 + 1);
			u16 scan_header_size = 2 + 1 + 3 * (1 + 1) + 1 + 1 + 1;
			result.init(
				+ 2
				+ 2 + QTableEncoder :: size(qtables)
				+ 2 + HuffmanEncoder :: size(htables)
				+ 2 + frame_header_size
				+ 2 + scan_header_size
				+ payload_size
				+ 2
			);
			u8* res = result.array;
			u8* mem = res;
			
			res = writeMarker(res, Marker :: SOI);
			mem = res;
			res =  QTableEncoder :: encode(qtables, res);
			if (mem + 2 + QTableEncoder :: size(qtables) != res) { std :: cerr << "QTableEncoder size mismatch" << std :: endl; return {}; }
			mem = res;
			res = HuffmanEncoder :: encode(htables, res);
			if (mem + 2 + HuffmanEncoder :: size(htables) != res) { std :: cerr << "HuffmanEncoder size mismatch" << std :: endl; return {}; }
			
			{ //	frame
				mem = res;
				Marker :: SOFData sof_data;
				sof_data.arithmetic = 0;
				sof_data.differential = 0;
				sof_data.mode = Marker :: SOFData :: Mode :: BASELINE;
				res = writeMarker(res, sof_data.toMarker());
				*res++ = frame_header_size >> 8;   //	Lf
				*res++ = frame_header_size & 0xFF; //	Lf
				*res++ = 8;                        //	P
				*res++ = height >> 8;              //	Y
				*res++ = height & 0xFF;            //	Y
				*res++ = width >> 8;               //	X
				*res++ = width & 0xFF;             //	X
				*res++ = 3;                        //	Nf
				for (int i = 0; i < 3; ++i) {
					*res++ = i + 1;                                              //	Ci
					*res++ = sampling_factors[i].x << 4 | sampling_factors[i].y; //	Hi|Vi
					*res++ = i == 0 ? 0 : 1;                                     //	Tqi
				}
				if (mem + 2 + frame_header_size != res) { std :: cerr << "Frame header size mismatch" << std :: endl; return {}; }
			}
			{ //	scan
				mem = res;
				res = writeMarker(res, Marker :: SOS);
				*res++ = scan_header_size >> 8;   //	Ls
				*res++ = scan_header_size & 0xFF; //	Ls
				*res++ = 3;                       //	Ns
				for (int i = 0; i < 3; ++i) {
					*res++ = i + 1;             //	Csi
					u8 h_id = i == 0 ? 0 : 1;
					*res++ = h_id << 4 | h_id;  //	Tdi|Tai
				}
				*res++ = 0;  //	Ss
				*res++ = 63; //	Se
				*res++ = 0;  //	Ah|Al
				if (mem + 2 + scan_header_size != res) { std :: cerr << "Scan header size mismatch" << std :: endl; return {}; }
				
				mem = res;
				for (int i = 0; i < old_payload_size; ++i) {
					*res++ = payload[i];
					if (payload[i] == 0xFF) {
						*res++ = 0x00;
					}
				}
				if (mem + payload_size != res) { std :: cerr << "Payload size mismatch" << std :: endl; return {}; }
			}
			
			res = writeMarker(res, Marker :: EOI);
			
			if (result.array + result.length != res) {
				clog("%d", res - result.array)
				clog("%d", result.length)
				std :: cerr << "Encode result size mismatch" << std :: endl;
				return {};
			}
			
			return result;
		}
		
		namespace {
			//	template <int N> struct MyString {char s[N + 1];};
			fun char* toBin(u16 x, u16 length) {
				static char s[17];
				
				for (int i = 0; i < length; ++i) {
					u16 mask = 1 << (length - 1 - i);
					s[i] = (x & mask) ? '1' : '0';
				}
				s[length] = '\0';
				return s;
			}
			
			fun void debugPrintCoefficientsEl(i32   x) { if (x != 0) { printf("%7d "  , x); } else { printf("      . "); } }
			fun void debugPrintCoefficientsEl(float x) { if (x != 0) { printf("%7.1f ", x); } else { printf("      . "); } }
			template <typename T = i32>
			fun bool debugPrintCoefficients(CLContext cl) {
				auto buffer = cl.buffer.coefficients;
				
				auto array = new FI[buffer.length][8][8];
				if (!array) { return false; }
				if (!buffer.read(cl.queue, array)) { return false; }
				for (int i = 0; i < 8; ++i) {
					for (int unit_index = 0; unit_index < buffer.length; ++unit_index) {
						for (int j = 0; j < 8; ++j) {
							debugPrintCoefficientsEl(*reinterpret_cast<T*>(&array[unit_index][i][j]));
						}
						printf("| ");
					}
					printf("\n");
				}
				printf("\n");
				return true;
			}
			
			namespace QTableEncoder {
				//	assume 16 bit, 3 components (0, 1, 1)
				fun size_t size(QuantizationTable table[4]) {
					return 2 + 2 * (1 + 64 * 2);
				}
				//	assume 16 bit, 3 components (0, 1, 1)
				fun u8* encode(QuantizationTable table[4], u8* dst) {
					dst = writeMarker(dst, Marker :: DQT);
					*dst++ = size(table) >> 8;
					*dst++ = size(table) & 0xFF;
					for (int id = 0; id < 2; ++id) {
						*dst++ = (1 << 4) | id;
						for (int i = 0; i < 64; ++i) {
							*dst++ = table[id][0][i] >> 8;
							*dst++ = table[id][0][i] & 0xFF;
						}
					}
					return dst;
				}
			}
			
			fun u32 prefixSumLengths(CLContext cl, u32 unit_count, u8 mcu_length) {
				
				u32 half_step;
				size_t work[1];
				for (half_step = 1; full_step < unit_count; half_step *= 2) {
					work[0] = unit_count / full_step;
					if (!cl.kernel.prefixSumLengths1.setArg_half_step(half_step)) { return 0; }
					if (!cl.kernel.prefixSumLengths1.call(cl.queue, work)) { return 0; }
				}
				
				while (half_step /= 2) {
					work[0] = (unit_count - half_step) / full_step;
					if (!cl.kernel.prefixSumLengths2.setArg_half_step(half_step)) { return 0; }
					if (!cl.kernel.prefixSumLengths2.call(cl.queue, work)) { return 0; }
				}
				
				u32 total_size = 0;
				if (!cl.buffer.lengths.read(cl.queue, &total_size, 1, unit_count)) { return 0; }
				clog("total_size = %zu", total_size);
				return total_size;
			}
			
			using HValuesType = decltype(CLContext :: Buffers :: hvalues_dc_0);
			fun bool countOccurances(CLContext cl, HValuesType hvalues, size_t hv_length, u8 id) {
				//	printf("%zu:   ", hv_length);
				//	if (!hvalues.debugWrite(cl.queue, hv_length, std :: cout, [](std :: ostream& stream, u8& t) { if (t == 0xE0) { stream << "x"; return; } u8 RRRR = t >> 4, SSSS = t & 0x0F; stream << RRRR << "|" << SSSS; })) { return false; }
				//	if (!hvalues.debugWrite(cl.queue, hv_length, std :: cout, [](std :: ostream& stream, u8& t) { if (t == 0xE0) { stream << "x"; return; } u8 RRRR = t >> 4, SSSS = t & 0x0F; stream << RRRR << "|" << (1 << SSSS >> 1); })) { return false; }
				//	clog();
				//	radix sort
				for (int pow = 0; pow < 8; ++pow) {
					if (!cl.kernel.radixSort_createAB.setArg_hvalues(hvalues)) { return false; }
					if (!cl.kernel.radixSort_rearange.setArg_hvalues(hvalues)) { return false; }
					
					if (!cl.kernel.radixSort_createAB.setArg_pow(pow)) { return false; }
					if (!cl.kernel.radixSort_createAB.call(cl.queue, { hv_length - 1 })) { return false; }
					
					u32 half_step = 1;
					for (; full_step - 1 < hv_length; half_step *= 2) {
						if (!cl.kernel.radixSort_prefixSum1.setArg_half_step(half_step)) { return false; }
						if (!cl.kernel.radixSort_prefixSum1.call(cl.queue, { hv_length / full_step })) { return false; }
					}
					while (half_step /= 2) {
						if (hv_length <= half_step) { continue; }
						if (!cl.kernel.radixSort_prefixSum2.setArg_half_step(half_step)) { return false; }
						if (!cl.kernel.radixSort_prefixSum2.call(cl.queue, { (hv_length - half_step) / full_step })) { return false; }
					}
					
					if (!cl.kernel.radixSort_rearange.setArg_hvalues_dst(cl.buffer.hvalues_temp)) { return false; }
					if (!cl.kernel.radixSort_rearange.setArg_pow        (pow                   )) { return false; }
					if (!cl.kernel.radixSort_rearange.call(cl.queue, { hv_length })) { return false; }
					
					cl_mem temp = hvalues.buffer;
					hvalues.buffer = cl.buffer.hvalues_temp.buffer;
					cl.buffer.hvalues_temp.buffer = temp;
						//	swap hvalue and hvalue_temp
						//	this will not be seen outside of this function, since cl is passed by copy
						//	buffers are not of the same length (propery in MyOpenCL :: Buffer),
						//	but that is ok if we don't use it ;)
						//	and we do this 8 times, so it cancels itself out
				}
				//	printf("%zu:   ", hv_length);
				//	if (!hvalues.debugWrite(cl.queue, hv_length, std :: cout, [](std :: ostream& stream, u8& t) { if (t == 0xE0) { stream << "x"; return; } u8 RRRR = t >> 4, SSSS = t & 0x0F; stream << RRRR << "|" << SSSS; })) { return false; }
				//	if (!hvalues.debugWrite(cl.queue, hv_length, std :: cout, [](std :: ostream& stream, u8& t) { if (t == 0xE0) { stream << "x"; return; } u8 RRRR = t >> 4, SSSS = t & 0x0F; stream << RRRR << "|" << (1 << SSSS >> 1); })) { return false; }
				//	clog();
				
				if (!cl.kernel.countOccurances1.setArg_hvalues(hvalues)) { return false; }
				if (!cl.kernel.countOccurances2.setArg_hvalues(hvalues)) { return false; }
				if (!cl.kernel.countOccurances2.setArg_id     (id     )) { return false; }
				
				if (!cl.kernel.initCountsLarge.call(cl.queue, { hv_length })) { return false; }
				
				{
					u32 half_step = 1;
					for (; full_step - 1 < hv_length; half_step *= 2) {
						if (!cl.kernel.countOccurances1.setArg_half_step(half_step)) { return false; }
						if (!cl.kernel.countOccurances1.call(cl.queue, { hv_length / full_step })) { return false; }
					}
					for (; half_step; half_step /= 2) {
						if (!cl.kernel.countOccurances2.setArg_half_step(half_step)) { return false; }
						if (!cl.kernel.countOccurances2.call(cl.queue, { (hv_length + half_step) / full_step })) { return false; }
					}
				}
				//	if (!cl.buffer.counts.debugWrite(cl.queue, 1, id, std :: cout, [](std :: ostream& s, u32 (&t)[256]) {
				//		for (u32 v = 0; v < 256; ++v) { printf("%3u ",   v ); } clog();
				//		for (u32 v = 0; v < 256; ++v) { if (t[v]) { printf("%3u ", t[v]); } else { printf("  . "); } } clog();
				//	})) { return false; }
				return true;
			}
		}
		
		fun bool ReadJpegDef(std :: string& path, QuantizationTable qtables[4], HuffmanTable htables[2][4]) {
			Resource<Decode :: InputFileBuffer> file(path);
			if (!file) {
				std :: cerr << "Failed to open file " << path << std :: endl;
				return false;
			}
			
			int i = 0;
			
			if (file[i++] != 0xFF || file[i++] != Marker :: SOI) { std :: cerr << "File is not a JPEG file" << std :: endl; return false; }
			
			while (i < file.length) {
				if (file[i++] != 0xFF) { return false;}
				u8 m = file[i++];
				if (m == Marker :: EOI) {
					return true;
				}
				u16 segment_length = (file[i] << 8) | file[i + 1]; i += 2;
				switch (m) {
					default: {
						if (Marker :: isAPP(m)) {
							//	fallthrough
						} else {
							return false;
						}
					}
					case Marker :: DAC: 
					case Marker :: DRI: 
					case Marker :: COM: {
						i += segment_length - 2;
					} break;
					case Marker :: DQT: {
						auto end = i + segment_length - 2;
						while (i < end) {
							u8 Pq, Tq; Pq = file[i] >> 4; Tq = file[i] & 0x0F; ++i;
							if (Tq > 3) { return false; }
							if (Pq == 0) { for (int j = 0; j < 64; ++j) { qtables[Tq][0][j] = file[i++]; } }
							else         { for (int j = 0; j < 64; ++j) { qtables[Tq][0][j] = (file[i] << 8) | file[i + 1]; i += 2; } }
						}
					} break;
					case Marker :: DHT: {
						auto end = i + segment_length - 2;
						while (i < end) {
							u8 table_class, table_dest; table_class = file[i] >> 4; table_dest = file[i] & 0x0F; ++i;
							if (table_class > 1 || table_dest > 3) { return false; }
							HuffmanTable& huffman = htables[table_class][table_dest];
							for (auto& c_l : huffman) { c_l = { 0, 0 }; }
							u32 const counts_start = i - 1; // because of 1-indexing
							u32 const values_start = i + 16;
							u16 code = 0;
							u8 value_index = 0;
							u8 last_length = 1;
							u32 last_code  = 0;
							for (u8 length = 1; length <= 16; ++length) {
								u8 const count = file[counts_start + length];
								for (u8 i = 0; i < count; ++i) {
									u8 value = file[values_start + value_index];
									huffman[value] = { code, length };
									
									++code;
									++value_index;
									
									last_code = code;
									last_length = length;
								}
								code <<= 1;
							}
							if (last_code + 1 != 1 << last_length) {
								return false;
							}
							i = values_start + value_index;
						}
					} break;
				}
				
				
			}
			return false;
		}
	}
}