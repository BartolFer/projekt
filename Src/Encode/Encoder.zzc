#include <bitset>

#include "../Util.zzh"
#include "../JpegTypes.zzh"
#include "../Markers.zzh"
#include "../MyOpenCL.zzh"
#include "./Huffman.zzh"
#include "./ClContext.zzh"
#include "../Decode/FileBuffer.zzh"

#pragma region zzc src_decl
	#define full_step (2 * half_step)
#pragma endregion zzc

namespace BJpeg {
	namespace Encode {
		fun ArrayWithLength<u8> image(MyOpenCL :: Buffer<RGBA> image, CLContext cl, size_t height, size_t width, QuantizationTable qtables[4], SamplingFactor sampling_factors[MAX_COMPONENTS]) {
			//	we will assume image has 3 components
			//	There are 2 qtables and 4 htables: 
			//		C1 has qtables[0] and both htables[DC/AC][0]
			//		C2 & C3 share qtables[1] and both htables[DC/AC][1]
			
			BJPEG_IF_DEBUG_ALL(if (!image.debugWrite(cl.queue, std :: cout, [](std::ostream& stream, BJpeg::RGBA& t) { stream << '(' << t.r << ',' << t.g << ',' << t.b << ')'; })) { clog("bbx eee 42") return {}; })
			
			HuffmanTable htables[2][4];
			
			LaneInfo lane_infos[MAX_MCU_LENGTH]; LaneInfo* lane_infos_ptr = lane_infos;
			u8 max_sf_y = 1;
			u8 max_sf_x = 1;
			u8 mcu_length = 0;
			for (u8 i = 0; i < 3; ++i) {
				auto sf = sampling_factors[i];
				if (sf.y > max_sf_y) { max_sf_y = sf.y; }
				if (sf.x > max_sf_x) { max_sf_x = sf.x; }
				mcu_length += sf.y * sf.x;
				for (int y = 0; y < sf.y; ++y) {
					for (int x = 0; x < sf.x; ++x) {
						lane_infos_ptr++->c_id = i + 1;
					}
				}
				lane_infos[i].sf_y = sf.y;
				lane_infos[i].sf_x = sf.x;
			}
			lane_infos[0].hvalues_step = lane_infos[0].sf_y * lane_infos[0].sf_x;
			lane_infos[1].hvalues_step = lane_infos[1].sf_y * lane_infos[1].sf_x + lane_infos[2].sf_y * lane_infos[2].sf_x;
			u8x2 max_sf = { max_sf_x, max_sf_y };
			size_t mcu_y = ROUND_UP_8(height) / 8 / max_sf_y;
			size_t mcu_x = ROUND_UP_8(width ) / 8 / max_sf_x;
			size_t mcu_count = mcu_x * mcu_y;
			size_t unit_count = mcu_count * mcu_length;
			clog("max_sf_y = %d", max_sf_y);
			clog("max_sf_x = %d", max_sf_x);
			clog("mcu_length = %d", mcu_length);
			clog("mcu_y = %d", mcu_y);
			clog("mcu_x = %d", mcu_x);
			clog("mcu_count = %d", mcu_count);
			clog("unit_count = %d", unit_count);
			
			if (!cl.buffer.htables   .write(cl.queue, htables   )) { clog("bbx eee 1") return {}; }
			if (!cl.buffer.qtables   .write(cl.queue, qtables   )) { clog("bbx eee 2") return {}; }
			if (!cl.buffer.lane_infos.write(cl.queue, lane_infos)) { clog("bbx eee 3") return {}; }
			
			size_t dc_count_0 = mcu_count *  sampling_factors[0].y * sampling_factors[0].x;
			size_t dc_count_1 = mcu_count * (sampling_factors[1].y * sampling_factors[1].x + sampling_factors[2].y * sampling_factors[2].x);
			
			if (!cl.initBuffers1(height, width, unit_count, max_sf, mcu_length, dc_count_0, dc_count_1)) { clog("bbx eee 4") return {}; }
			defer { cl.finishBuffers1(); };
			
			if (!cl.kernel.RGB_to_YCbCr.setArg_image(image)) { clog("bbx eee 5") return {}; }
			if (!cl.kernel.RGB_to_YCbCr.call(cl.queue, { height, width })) { clog("bbx eee 6") return {}; }
			#ifdef BJPEG_DEBUG_ALL
				if (!cl.buffer.image_temp.debugWrite(cl.queue, std :: cout, [](std::ostream& stream, BJpeg::RGBAF& t) { stream << '(' << t.r << ',' << t.g << ',' << t.b << ')'; })) { clog("bbx eee 7") return {}; }
			#endif
			
			//	TODO fill missing in both de & en
			if (!cl.kernel.interleave_downsample.call(cl.queue, { mcu_y, mcu_x })) { clog("bbx eee 8") return {}; }
			BJPEG_IF_DEBUG_ALL(if (!debugPrintCoefficients<f32>(cl)) { clog("bbx eee 9") return {}; })
			
			if (!cl.kernel.dct_quantization_zigzag.call(cl.queue, { mcu_count, mcu_length })) { clog("bbx eee 10") return {}; }
			BJPEG_IF_DEBUG_ALL(if (!debugPrintCoefficients<i32>(cl)) { clog("bbx eee 11") return {}; })
			
			//	FI fi0; if (!cl.buffer.coefficients.read(cl.queue, &fi0, 0, 0, 1, 0)) { clog("bbx eee 12") return {}; } clog("fi = %d or %f", fi0.i, fi0.f);
			if (!cl.kernel.deltaDC1.call(cl.queue, { mcu_count })) { clog("bbx eee 13") return {}; }
			if (!cl.kernel.deltaDC2.call(cl.queue, { unit_count })) { clog("bbx eee 14") return {}; }
			BJPEG_IF_DEBUG_ALL(if (!debugPrintCoefficients<i32>(cl)) { clog("bbx eee 15") return {}; })
			
			{ //	generate Huffman
				if (!cl.kernel.initCounts         .call(cl.queue, { 4, 256 })) { clog("bbx eee 16") return {}; }
				//	if (!cl.buffer.hvalues_dc_0.debugWrite(cl.queue, 1)) { clog("bbx eee 17") return {}; }
				if (!cl.kernel.gatherHuffmanValues.call(cl.queue, { mcu_count })) { clog("bbx eee 18") return {}; }
				
				#ifdef BJPEG_DEBUG_ALL
					if (!cl.buffer.hvalues_dc_0.debugWrite(cl.queue, std :: cout, [](std::ostream& stream, u8& t) { stream << (t >> 4) << '|' << (t & 0x0F); })) { clog("bbx eee 19 0") return {}; }
					if (!cl.buffer.hvalues_dc_1.debugWrite(cl.queue, std :: cout, [](std::ostream& stream, u8& t) { stream << (t >> 4) << '|' << (t & 0x0F); })) { clog("bbx eee 19 1") return {}; }
					if (!cl.buffer.hvalues_ac_0.debugWrite(cl.queue, std :: cout, [](std::ostream& stream, u8& t) { stream << (t >> 4) << '|' << (t & 0x0F); })) { clog("bbx eee 19 2") return {}; }
					if (!cl.buffer.hvalues_ac_1.debugWrite(cl.queue, std :: cout, [](std::ostream& stream, u8& t) { stream << (t >> 4) << '|' << (t & 0x0F); })) { clog("bbx eee 19 3") return {}; }
				#endif
				//	debugPrintCoefficients(cl);
				//	FI fi0; if (!cl.buffer.coefficients.read(cl.queue, &fi0, 0, 0, 1, 0)) { clog("bbx eee 20") return {}; } clog("fi = %d or %f", fi0.i, fi0.f);
				//	if (!cl.buffer.hvalues_dc_0.debugWrite(cl.queue)) { clog("bbx eee 21") return {}; } clog();
				if (!countOccurances(cl, cl.buffer.hvalues_dc_0, dc_count_0     , 0b00)) { clog("bbx eee 22") return {}; }
				//	if (!cl.buffer.hvalues_dc_0.debugWrite(cl.queue)) { clog("bbx eee 23") return {}; } clog();
				
				
				//	u32 counts[4][256];
				//	if (!cl.buffer.counts.read(cl.queue, counts)) { clog("bbx eee 24") return {}; }
				//	//	std :: cout << "[ "; for (u32 x : counts[0]) { if (x) std :: cout << x << ", "; else std :: cout << "." << ", "; } std :: cout << " ]" << std :: endl;
				if (!countOccurances(cl, cl.buffer.hvalues_dc_1, dc_count_1     , 0b01)) { clog("bbx eee 25") return {}; }
				if (!countOccurances(cl, cl.buffer.hvalues_ac_0, dc_count_0 * 63, 0b10)) { clog("bbx eee 26") return {}; }
				if (!countOccurances(cl, cl.buffer.hvalues_ac_1, dc_count_1 * 63, 0b11)) { clog("bbx eee 27") return {}; }
				
				u32 counts[4][256];
				if (!cl.buffer.counts.read(cl.queue, counts)) { clog("bbx eee 28") return {}; }
				//	std :: cout << "[ "; for (u32 x : counts[0]) { if (x) std :: cout << x << ", "; else std :: cout << "." << ", "; } std :: cout << " ]" << std :: endl;
				
				HuffmanEncoder :: generateTable(counts[0b00], htables[0][0]);
				//	std :: cout << "[ "; for (u32 x : counts[0]) { if (x) std :: cout << x << ", "; else std :: cout << "." << ", "; } std :: cout << " ]" << std :: endl;
				//	std :: cout << "[ "; for (auto [c, x] : htables[0][0]) { if (x) std :: cout << x << ", "; else std :: cout << "." << ", "; } std :: cout << " ]" << std :: endl;
				//	std :: cout << "[ "; for (u32 v = 0; v < 256; ++v) { auto [c, l] = htables[0][0][v]; if (l) std :: cout << v << ":" << l << " "; else std :: cout << "." << " "; } std :: cout << " ]" << std :: endl;
				HuffmanEncoder :: generateTable(counts[0b01], htables[0][1]);
				HuffmanEncoder :: generateTable(counts[0b10], htables[1][0]);
				HuffmanEncoder :: generateTable(counts[0b11], htables[1][1]);
				//	std :: cout << "[ "; for (auto [c, x] : htables[0][0]) { if (x) std :: cout << x << ", "; else std :: cout << "." << ", "; } std :: cout << " ]" << std :: endl;
				#ifdef BJPEG_DEBUG_ALL
					for (int cls = 0; cls < 2; ++cls) {
						for (int dst = 0; dst < 2; ++dst) {
							clog("Huffman %cC %d", cls?'A':'D', dst);
							for (int v = 0; v < 256; ++v) {
								auto [c, l] = htables[cls][dst][v];
								u8 RRRR = v >> 4, SSSS = v & 0x0F;
								if (l == 0) { continue; }
								clog("\t\t\t%u|%u/%u: %s", RRRR, SSSS, 1 << SSSS >> 1, toBin(c, l));
							}
						}
					}
				#endif
				
				if (!cl.buffer.htables.write(cl.queue, htables)) { clog("bbx eee 29") return {}; }
			}
			//	debugPrintCoefficients(cl);
			
			if (!cl.kernel.encodeHuffman.call(cl.queue, { mcu_count, mcu_length })) { clog("bbx eee 30") return {}; }
			#ifdef BJPEG_DEBUG_ALL
			{
				u32      * lengths = new u32      [unit_count]; if (!lengths) { clog("bbx eee 31") return {}; } defer { delete[] lengths; };
				CodedUnit* codes   = new CodedUnit[unit_count]; if (!codes  ) { clog("bbx eee 32") return {}; } defer { delete[] codes  ; };
				if (!cl.buffer.lengths.read(cl.queue, lengths, unit_count, 1)) { clog("bbx eee 33") return {}; }
				if (!cl.buffer.codes  .read(cl.queue, codes  , unit_count, 0)) { clog("bbx eee 34") return {}; }
				for (int i = 0; i < unit_count; ++i) {
					u32 length = lengths[i];
					CodedUnit& code = codes[i];
					printf("%5u: ", length);
					for (int i = 0; i < length / 32; ++i) {
						for (int j = 32; j-- > 0; ) {
							putchar(code[i] >> j & 1 ? '1' : '0');
						}
						putchar(' ');
					}
					for (int j = 32; j-- > 32 - length % 32; ) {
						putchar(code[length / 32] >> j & 1 ? '1' : '0');
					}
					putchar('\n');
				}
				if (!cl.buffer.lengths.debugWrite(cl.queue, unit_count + 1, 0)) { clog("bbx eee 35") return {}; }
			}
			#endif
			
			u32 total_size = prefixSumLengths(cl, unit_count, mcu_length);
			BJPEG_IF_DEBUG_ALL(if (!cl.buffer.lengths.debugWrite(cl.queue, unit_count + 1, 0)) { clog("bbx eee 36") return {}; })
			if (total_size == 0) { clog("bbx eee 37") return {}; }
			size_t payload_size = ROUND_UP_8(total_size) / 8;
			if (!cl.initBuffers2(payload_size)) { clog("bbx eee 38") return {}; }
			defer { cl.finishBuffers2(); };
			
			#define BJPEG_MAX_GLOBAL_WORK_HERE (((size_t)1U) << 13) //	8192
			size_t remaining_work = unit_count;
			size_t offset = 0;
			int bbx_counter = 0;
			for (; remaining_work > BJPEG_MAX_GLOBAL_WORK_HERE; remaining_work -= BJPEG_MAX_GLOBAL_WORK_HERE, offset += BJPEG_MAX_GLOBAL_WORK_HERE) {
				//	clog("BBX counter %d", bbx_counter++);
				if (!cl.kernel.concatCodes.call(cl.queue, { BJPEG_MAX_GLOBAL_WORK_HERE }, { offset })) { clog("bbx eee 39") return {}; }
			}
			//	clog("BBX ct last %d", bbx_counter++);
			if (!cl.kernel.concatCodes.call(cl.queue, { remaining_work }, { offset })) { clog("bbx eee 40") return {}; }
			
			u8* payload = new u8[payload_size];
			if (!payload) { std :: cerr << "Not enough RAM" << std :: endl; return {}; }
			defer { delete[] payload; };
			if (!cl.buffer.payload.read(cl.queue, payload, payload_size)) { clog("bbx eee 41") return {}; }
			BJPEG_IF_DEBUG_ALL(if (!cl.buffer.payload.debugWrite(cl.queue, std :: cout, [](std::ostream& stream, BJpeg::u8& t) { stream << std :: bitset<8>(t); })) { clog("bbx eee 0") return {}; })
			//	clog("01100101 10100111 10001011 10001101 01100111 01010001 11011011 00100101 10110110 01100001 10111000 00011100 01101000 01010100 10000000 00111001 00111110 00000110 11100110 00101011 00000100 00111010 01001010 01110100 00111110 11111010 10001010 11101001 00001110 11101000 11010111 10101110 00011011 10110101 01110110 10010010 10111010 01011110 00111110 01100010 11100001 01011111 00110110 11001011 11011110 10110110 00010011 00011000 10111100 10001000 00111110 10010000 11100101 01000111 11100010 00111110 10000101 10000100 00010101 00101101 10100000 10000100 00111010 01001010 01011101 1111010")
			//	clog();
			//	for (int i = 0; i < payload_size; ++i) {
			//		std :: cout << std :: bitset<8>(payload[i]) ; //	<< " ";
			//	} std :: cout << std :: endl;
			
			size_t old_payload_size = payload_size;
			for (int i = 0; i < old_payload_size; ++i) {
				if (payload[i] == 0xFF) {
					++payload_size;
				}
			}
			clog("%u -> %u", old_payload_size, payload_size);
			
			ArrayWithLength<u8> result;
			u16 frame_header_size = 2 + 1 + 2 + 2 + 1 + 3 * (1 + 1 + 1);
			u16 scan_header_size = 2 + 1 + 3 * (1 + 1) + 1 + 1 + 1;
			result.init(
				+ 2
				+ 2 + QTableEncoder :: size(qtables)
				+ 2 + HuffmanEncoder :: size(htables)
				+ 2 + frame_header_size
				+ 2 + scan_header_size
				+ payload_size
				+ 2
			);
			u8* res = result.array;
			u8* mem = res;
			
			res = writeMarker(res, Marker :: SOI);
			mem = res;
			res =  QTableEncoder :: encode(qtables, res);
			if (mem + 2 + QTableEncoder :: size(qtables) != res) { std :: cerr << "QTableEncoder size mismatch" << std :: endl; return {}; }
			mem = res;
			res = HuffmanEncoder :: encode(htables, res);
			if (mem + 2 + HuffmanEncoder :: size(htables) != res) { std :: cerr << "HuffmanEncoder size mismatch" << std :: endl; return {}; }
			
			{ //	frame
				mem = res;
				Marker :: SOFData sof_data;
				sof_data.arithmetic = 0;
				sof_data.differential = 0;
				sof_data.mode = Marker :: SOFData :: Mode :: BASELINE;
				res = writeMarker(res, sof_data.toMarker());
				*res++ = frame_header_size >> 8;   //	Lf
				*res++ = frame_header_size & 0xFF; //	Lf
				*res++ = 8;                        //	P
				*res++ = height >> 8;              //	Y
				*res++ = height & 0xFF;            //	Y
				*res++ = width >> 8;               //	X
				*res++ = width & 0xFF;             //	X
				*res++ = 3;                        //	Nf
				for (int i = 0; i < 3; ++i) {
					*res++ = i + 1;                                              //	Ci
					*res++ = sampling_factors[i].x << 4 | sampling_factors[i].y; //	Hi|Vi
					*res++ = i == 0 ? 0 : 1;                                     //	Tqi
				}
				if (mem + 2 + frame_header_size != res) { std :: cerr << "Frame header size mismatch" << std :: endl; return {}; }
			}
			{ //	scan
				mem = res;
				res = writeMarker(res, Marker :: SOS);
				*res++ = scan_header_size >> 8;   //	Ls
				*res++ = scan_header_size & 0xFF; //	Ls
				*res++ = 3;                       //	Ns
				for (int i = 0; i < 3; ++i) {
					*res++ = i + 1;             //	Csi
					u8 h_id = i == 0 ? 0 : 1;
					*res++ = h_id << 4 | h_id;  //	Tdi|Tai
				}
				*res++ = 0;  //	Ss
				*res++ = 63; //	Se
				*res++ = 0;  //	Ah|Al
				if (mem + 2 + scan_header_size != res) { std :: cerr << "Scan header size mismatch" << std :: endl; return {}; }
				
				mem = res;
				for (int i = 0; i < old_payload_size; ++i) {
					*res++ = payload[i];
					if (payload[i] == 0xFF) {
						*res++ = 0x00;
					}
				}
				if (mem + payload_size != res) { std :: cerr << "Payload size mismatch" << std :: endl; return {}; }
			}
			
			res = writeMarker(res, Marker :: EOI);
			
			if (result.array + result.length != res) {
				clog("%d", res - result.array)
				clog("%d", result.length)
				std :: cerr << "Encode result size mismatch" << std :: endl;
				return {};
			}
			
			return result;
		}
		
		namespace {
			//	template <int N> struct MyString {char s[N + 1];};
			fun char* toBin(u16 x, u16 length) {
				static char s[17];
				
				for (int i = 0; i < length; ++i) {
					u16 mask = 1 << (length - 1 - i);
					s[i] = (x & mask) ? '1' : '0';
				}
				s[length] = '\0';
				return s;
			}
			
			fun void debugPrintCoefficientsEl(i32   x) { if (x != 0) { printf("%7d "  , x); } else { printf("      . "); } }
			fun void debugPrintCoefficientsEl(float x) { if (x != 0) { printf("%7.1f ", x); } else { printf("      . "); } }
			template <typename T = i32>
			fun bool debugPrintCoefficients(CLContext cl) {
				auto buffer = cl.buffer.coefficients;
				
				auto array = new FI[buffer.length][8][8];
				if (!array) { return false; }
				if (!buffer.read(cl.queue, array)) { return false; }
				for (int i = 0; i < 8; ++i) {
					for (int unit_index = 0; unit_index < buffer.length; ++unit_index) {
						for (int j = 0; j < 8; ++j) {
							debugPrintCoefficientsEl(*reinterpret_cast<T*>(&array[unit_index][i][j]));
						}
						printf("| ");
					}
					printf("\n");
				}
				printf("\n");
				return true;
			}
			template <typename T = i32>
			fun bool debugPrintCoefficientsDC(CLContext cl) {
				auto buffer = cl.buffer.coefficients;
				
				auto array = new FI[buffer.length][8][8];
				if (!array) { return false; }
				if (!buffer.read(cl.queue, array)) { return false; }
				for (int unit_index = 0; unit_index < buffer.length; ++unit_index) {
					debugPrintCoefficientsEl(*reinterpret_cast<T*>(&array[unit_index][0][0]));
					printf("| ");
				}
				printf("\n");
				return true;

			}
			
			namespace QTableEncoder {
				//	assume 16 bit, 3 components (0, 1, 1)
				fun size_t size(QuantizationTable table[4]) {
					return 2 + 2 * (1 + 64 * 2);
				}
				//	assume 16 bit, 3 components (0, 1, 1)
				fun u8* encode(QuantizationTable table[4], u8* dst) {
					dst = writeMarker(dst, Marker :: DQT);
					*dst++ = size(table) >> 8;
					*dst++ = size(table) & 0xFF;
					for (int id = 0; id < 2; ++id) {
						*dst++ = (1 << 4) | id;
						for (int i = 0; i < 64; ++i) {
							*dst++ = table[id][0][i] >> 8;
							*dst++ = table[id][0][i] & 0xFF;
						}
					}
					return dst;
				}
			}
			
			fun u32 prefixSumLengths(CLContext cl, u32 unit_count, u8 mcu_length) {
				
				u32 half_step;
				size_t work[1];
				for (half_step = 1; full_step <= unit_count; half_step *= 2) {
					work[0] = unit_count / full_step;
					if (!cl.kernel.prefixSumLengths1.setArg_half_step(half_step)) { return 0; }
					if (!cl.kernel.prefixSumLengths1.call(cl.queue, work)) { return 0; }
				}
				
				while (half_step /= 2) {
					work[0] = (unit_count - half_step) / full_step;
					if (!cl.kernel.prefixSumLengths2.setArg_half_step(half_step)) { return 0; }
					if (!cl.kernel.prefixSumLengths2.call(cl.queue, work)) { return 0; }
				}
				
				u32 total_size = 0;
				if (!cl.buffer.lengths.read(cl.queue, &total_size, 1, unit_count)) { return 0; }
				clog("total_size = %zu", total_size);
				return total_size;
			}
			
			using HValuesType = decltype(CLContext :: Buffers :: hvalues_dc_0);
			fun bool countOccurances(CLContext cl, HValuesType hvalues, size_t hv_length, u8 id) {
				//	printf("%zu:   ", hv_length);
				//	if (!hvalues.debugWrite(cl.queue, hv_length, std :: cout, [](std :: ostream& stream, u8& t) { if (t == 0xE0) { stream << "x"; return; } u8 RRRR = t >> 4, SSSS = t & 0x0F; stream << RRRR << "|" << SSSS; })) { return false; }
				//	if (!hvalues.debugWrite(cl.queue, hv_length, std :: cout, [](std :: ostream& stream, u8& t) { if (t == 0xE0) { stream << "x"; return; } u8 RRRR = t >> 4, SSSS = t & 0x0F; stream << RRRR << "|" << (1 << SSSS >> 1); })) { return false; }
				//	clog();
				//	radix sort
				for (int pow = 0; pow < 8; ++pow) {
					if (!cl.kernel.radixSort_createAB.setArg_hvalues(hvalues)) { return false; }
					if (!cl.kernel.radixSort_rearange.setArg_hvalues(hvalues)) { return false; }
					
					if (!cl.kernel.radixSort_createAB.setArg_pow(pow)) { return false; }
					if (!cl.kernel.radixSort_createAB.call(cl.queue, { hv_length - 1 })) { return false; }
					
					u32 half_step = 1;
					for (; full_step - 1 < hv_length; half_step *= 2) {
						if (!cl.kernel.radixSort_prefixSum1.setArg_half_step(half_step)) { return false; }
						if (!cl.kernel.radixSort_prefixSum1.call(cl.queue, { hv_length / full_step })) { return false; }
					}
					while (half_step /= 2) {
						if (hv_length <= half_step) { continue; }
						if (!cl.kernel.radixSort_prefixSum2.setArg_half_step(half_step)) { return false; }
						if (!cl.kernel.radixSort_prefixSum2.call(cl.queue, { (hv_length - half_step) / full_step })) { return false; }
					}
					
					if (!cl.kernel.radixSort_rearange.setArg_hvalues_dst(cl.buffer.hvalues_temp)) { return false; }
					if (!cl.kernel.radixSort_rearange.setArg_pow        (pow                   )) { return false; }
					if (!cl.kernel.radixSort_rearange.call(cl.queue, { hv_length })) { return false; }
					
					cl_mem temp = hvalues.buffer;
					hvalues.buffer = cl.buffer.hvalues_temp.buffer;
					cl.buffer.hvalues_temp.buffer = temp;
						//	swap hvalue and hvalue_temp
						//	this will not be seen outside of this function, since cl is passed by copy
						//	buffers are not of the same length (propery in MyOpenCL :: Buffer),
						//	but that is ok if we don't use it ;)
						//	and we do this 8 times, so it cancels itself out
				}
				//	printf("%zu:   ", hv_length);
				//	if (!hvalues.debugWrite(cl.queue, hv_length, std :: cout, [](std :: ostream& stream, u8& t) { if (t == 0xE0) { stream << "x"; return; } u8 RRRR = t >> 4, SSSS = t & 0x0F; stream << RRRR << "|" << SSSS; })) { return false; }
				//	if (!hvalues.debugWrite(cl.queue, hv_length, std :: cout, [](std :: ostream& stream, u8& t) { if (t == 0xE0) { stream << "x"; return; } u8 RRRR = t >> 4, SSSS = t & 0x0F; stream << RRRR << "|" << (1 << SSSS >> 1); })) { return false; }
				//	clog();
				
				if (!cl.kernel.countOccurances1.setArg_hvalues(hvalues)) { return false; }
				if (!cl.kernel.countOccurances2.setArg_hvalues(hvalues)) { return false; }
				if (!cl.kernel.countOccurances2.setArg_id     (id     )) { return false; }
				
				if (!cl.kernel.initCountsLarge.call(cl.queue, { hv_length })) { return false; }
				
				{
					u32 half_step = 1;
					for (; full_step - 1 < hv_length; half_step *= 2) {
						if (!cl.kernel.countOccurances1.setArg_half_step(half_step)) { return false; }
						if (!cl.kernel.countOccurances1.call(cl.queue, { hv_length / full_step })) { return false; }
					}
					for (; half_step; half_step /= 2) {
						if (!cl.kernel.countOccurances2.setArg_half_step(half_step)) { return false; }
						if (!cl.kernel.countOccurances2.call(cl.queue, { (hv_length + half_step) / full_step })) { return false; }
					}
				}
				//	if (!cl.buffer.counts.debugWrite(cl.queue, 1, id, std :: cout, [](std :: ostream& s, u32 (&t)[256]) {
				//		for (u32 v = 0; v < 256; ++v) { printf("%3u ",   v ); } clog();
				//		for (u32 v = 0; v < 256; ++v) { if (t[v]) { printf("%3u ", t[v]); } else { printf("  . "); } } clog();
				//	})) { return false; }
				return true;
			}
		}
		
		fun bool ReadJpegDef(std :: string& path, QuantizationTable qtables[4]) {
			Resource<Decode :: InputFileBuffer> file(path);
			if (!file) {
				std :: cerr << "Failed to open file " << path << std :: endl;
				return false;
			}
			
			int i = 0;
			
			if (file[i++] != 0xFF || file[i++] != Marker :: SOI) { std :: cerr << "File is not a JPEG file" << std :: endl; return false; }
			
			while (i < file.length) {
				if (file[i++] != 0xFF) { return false;}
				u8 m = file[i++];
				if (m == Marker :: EOI) {
					return true;
				}
				u16 segment_length = (file[i] << 8) | file[i + 1]; i += 2;
				switch (m) {
					default: {
						if (Marker :: isAPP(m)) {
							//	fallthrough
						} else {
							return false;
						}
					}
					case Marker :: DAC: 
					case Marker :: DRI: 
					case Marker :: DHT: 
					case Marker :: COM: {
						i += segment_length - 2;
					} break;
					case Marker :: DQT: {
						auto end = i + segment_length - 2;
						while (i < end) {
							u8 Pq, Tq; Pq = file[i] >> 4; Tq = file[i] & 0x0F; ++i;
							if (Tq > 3) { return false; }
							if (Pq == 0) { for (int j = 0; j < 64; ++j) { qtables[Tq][0][j] = file[i++]; } }
							else         { for (int j = 0; j < 64; ++j) { qtables[Tq][0][j] = (file[i] << 8) | file[i + 1]; i += 2; } }
						}
					} break;
				}
			}
			return false;
		}
	}
}