
#pragma region zzc hdr_decl
	#include "../Util.zzh"
	#include "../JpegTypes.zzh"
#pragma endregion zzc
#pragma region zzc src_decl
	#include <string.h>
	#include <iostream>
	#ifdef fun
	#undef fun //	<algorithm> (or rather ranges_algo.h) uses fun as a member of in_fun_result
	#include <algorithm>
	#define fun
	#endif
	#include "../Markers.zzh"
#pragma endregion zzc

namespace BJpeg {
	namespace Encode {
		struct CodeAndLength {
			u16 code;
			u16 length;
		};
		using HuffmanTable = CodeAndLength[256];
		namespace HuffmanEncoder {
			//	assume 3 components (0, 1, 1)
			fun size_t size(HuffmanTable table[2][4]) {
				size_t size = 2;
				for (int dc_ac = 0; dc_ac < 2; ++dc_ac) {
					for (int id = 0; id < 2; ++id) {
						size += 1 + 16;
						for (int value = 0; value < 256; ++value) {
							if (table[dc_ac][id][value].length) {
								++size;
							}
						}
					}
				}
				return size;
			}
			//	assume 3 components (0, 1, 1)
			fun u8* encode(HuffmanTable table[2][4], u8* dst) {
				writeMarker(dst, Marker :: DHT);
				//	dst[2] = later
				//	dst[3] = later
				size_t size = 2;
				for (int dc_ac = 0; dc_ac < 2; ++dc_ac) {
					for (int id = 0; id < 2; ++id) {
						u8 sorted_values[256]; for (u16 v = 0; v < 256; ++v) { sorted_values[v] = v; }
						HuffmanTable& huf = table[dc_ac][id];
						std :: sort(std :: begin(sorted_values), std :: end(sorted_values), [&huf] (auto a, auto b) { return huf[a].code < huf[b].code; }); //	if a.code < b.code, then a.length < b.length
						
						dst[2 + size] = (dc_ac << 4) | id;
						u8* counts = &dst[2 + size + 1 - 1]; //	offset by 1 because 1st length is 1
						u8* values = &dst[2 + size + 1 + 16];
						size += 1 + 16;
						for (int l = 1; l <= 16; ++l) { counts[l] = 0; }
						int value_index = 0;
						for (int i = 0; i < 256; ++i) {
							u8 value = sorted_values[i];
							auto [code, length] = huf[value];
							if (length) {
								++counts[length];
								++size;
								values[value_index++] = value;
							}
						}
					}
				}
				dst[2] = size >> 8;
				dst[3] = size & 0xFF;
				return dst + 2 + size;
			}
			fun void generateTable(u32 (&frequencies)[256], HuffmanTable& huffman) {
				constexpr u8 VALUE_THAT_IS_NOT_USED = 0XE0;
				frequencies[VALUE_THAT_IS_NOT_USED] = 1;
				u8  code_size[256] = { 0 };
				i16 others   [256]; for (auto& x : others) { x = -1; }
				auto searchLeastFrequent = [&frequencies](int v0 = -1) {
					u32 min_f = UINT32_MAX;
					u8 res = v0;
					for (u8 v = 256 - 1; v-- > 0; ) {
						if (v == v0) { continue; }
						auto f = frequencies[v];
						if (f > 0 && f < min_f) {
							min_f = f;
							res = v;
						}
					}
					return res;
				};
				
				//	log("frequencies: " << frequencies);
				
				//	Code_SIZE
				while (true) {
					i16 v1 = searchLeastFrequent();
					i16 v2 = searchLeastFrequent(v1);
					if (v2 == v1) { break; }
					frequencies[v1] += frequencies[v2];
					frequencies[v2] = 0;
					while (true) {
						++code_size[v1];
						if (others[v1] == -1) { break; }
						v1 = others[v1];
					}
					others[v1] = v2;
					while (true) {
						++code_size[v2];
						if (others[v2] == -1) { break; }
						v2 = others[v2];
					}
				}
				//	log("code_size:   " << code_size);
				
				//	Count_BITS
				u8 bits[32] = { 0 };
				//	log("bits: " << bits);
				for (int i = 0; i < 256; ++i) {
					auto cs = code_size[i];
					if (cs != 0) {
						//	clog("cs = %u", cs);
						++bits[cs - 1];
					}
				}
				//	log("bits: " << bits);
				
				//	Adjust_BITS
				int i = 31;
				for (; i > 15; --i) {
					while (bits[i] > 0) {
						int j = i - 1;
						do { --j; } while (bits[j] == 0);
						bits[i    ] -= 2;
						bits[i - 1] += 1;
						bits[j + 1] += 2;
						bits[j    ] -= 1;
					}
				}
				while (bits[i] == 0) { --i; }
				--bits[i]; //	remove last code
				code_size[VALUE_THAT_IS_NOT_USED] = 0;
				//	log("bits: " << bits);
				//	log("code_size: " << code_size);
				
				//	fill table
				u8 values[256]; for (int v = 0; v < 256; ++v) { values[v] = v; }
				std :: stable_sort(std :: begin(values), std :: end(values), [&code_size](u8 v1, u8 v2) {
					auto c1 = code_size[v1];
					auto c2 = code_size[v2];
					if (c1 == 0) { return false; }
					if (c2 == 0) { return true; }
					return c1 < c2;
				});
				//	log("values: " << values);
				for (auto& c_l : huffman) { c_l = { 0, 0 }; }
				u16 code = 0;
				u8 value_index = 0;
				u8 last_length = 1;
				u32 last_code  = 0;
				for (u8 length = 1; length <= 16; ++length) {
					u8 const count = bits[length - 1];
					for (u8 i = 0; i < count; ++i) {
						u8 value = values[value_index];
						//	clog("H v=%u   L=%u    cs=%u", value, length, code_size[value]);
						huffman[value] = { code, length };
						
						++code;
						++value_index;
						
						last_code = code;
						last_length = length;
					}
					code <<= 1;
				}
				//	log("Done\n");
			}
		}
		//	This should've gone to Encoder.zzc, but bug in ZZC causes error when using circular imports
		fun inline u8* writeMarker(u8* dst, u8 marker) {
			*dst++ = 0xFF;
			*dst++ = marker;
			return dst;
		}
	}
}