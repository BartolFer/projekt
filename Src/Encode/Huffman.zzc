
#pragma region zzc hdr_decl
	#include "../Util.zzh"
	#include "../JpegTypes.zzh"
#pragma endregion zzc
#pragma region zzc src_decl
	#include <string.h>
	#ifdef fun
	#undef fun //	<algorithm> (or rather ranges_algo.h) uses fun as a member of in_fun_result
	#include <algorithm>
	#define fun
	#endif
	#include "../Markers.zzh"
#pragma endregion zzc

namespace BJpeg {
	namespace Encode {
		struct CodeAndLength {
			u16 code;
			u16 length;
		};
		using HuffmanTable = CodeAndLength[256];
		namespace HuffmanEncoder {
			//	assume 3 components (0, 1, 1)
			fun size_t size(HuffmanTable table[2][4]) {
				size_t size = 2;
				for (int dc_ac = 0; dc_ac < 2; ++dc_ac) {
					for (int id = 0; id < 2; ++id) {
						size += 1 + 16;
						for (int value = 0; value < 256; ++value) {
							if (table[dc_ac][id][value].length) {
								++size;
							}
						}
					}
				}
				return size;
			}
			//	assume 3 components (0, 1, 1)
			fun u8* encode(HuffmanTable table[2][4], u8* dst) {
				writeMarker(dst, Marker :: DHT);
				//	dst[2] = later
				//	dst[3] = later
				size_t size = 2;
				for (int dc_ac = 0; dc_ac < 2; ++dc_ac) {
					for (int id = 0; id < 2; ++id) {
						u8 sorted_values[256]; for (u16 v = 0; v < 256; ++v) { sorted_values[v] = v; }
						HuffmanTable& huf = table[dc_ac][id];
						std :: sort(std :: begin(sorted_values), std :: end(sorted_values), [&huf] (auto a, auto b) { return huf[a].code < huf[b].code; }); //	if a.code < b.code, then a.length < b.length
						
						dst[2 + size] = (dc_ac << 4) | id;
						u8* counts = &dst[2 + size + 1 - 1]; //	offset by 1 because 1st length is 1
						u8* values = &dst[2 + size + 1 + 16];
						size += 1 + 16;
						for (int l = 1; l <= 16; ++l) { counts[l] = 0; }
						int value_index = 0;
						for (int i = 0; i < 256; ++i) {
							u8 value = sorted_values[i];
							auto [code, length] = huf[value];
							if (length) {
								++counts[length];
								++size;
								values[value_index++] = value;
							}
						}
					}
				}
				dst[2] = size >> 8;
				dst[3] = size & 0xFF;
				return dst + 2 + size;
			}
		}
		//	This should've gone to Encoder.zzc, but bug in ZZC causes error when using circular imports
		fun inline u8* writeMarker(u8* dst, u8 marker) {
			*dst++ = 0xFF;
			*dst++ = marker;
			return dst;
		}
	}
}