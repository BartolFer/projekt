#ifndef VSCODE_ONLY
	#hdr
		#pragma once
		#include <cstdint>
		#include <type_traits>
		// #include <cstddef>
		#include "./Util.hpp"
		#include "./FileBuffer.hpp"
		#include "./Context.hpp"
	#end
	#src
		#include <string.h>
		#include <iostream>
		#include <bit>
		#include "./Huffman.hpp"
		#include "./Markers.hpp"
		#include "./Test.hpp"
	#end
#else // if VSCODE
	#include <cstdint>
	#include <type_traits>
	// #include <cstddef>
	#include <string.h>
	#include <iostream>
	#include <bit>
	#include "./DecodeScan.hpp"
	#include "./Util.hpp"
	#include "./FileBuffer.hpp"
	#include "./Context.hpp"
	#include "./Huffman.hpp"
	#include "./Markers.hpp"
	#include "./Test.hpp"
#endif

#include "./DecoderMacro.hzz"

#define RESET_SCAN_CONTEXT() do for (int ci = 0; ci < MAX_COMPONENTS; ++ci) { auto C = component_order[ci]; context.component_data[C].predictor = 0; } while (0)

namespace BJpeg {
	namespace Decode {
		DECODE_FUN(scan) {
			// interpret header
			uint32_t result;
			ASSERT_MARKER(Marker :: SOS);
			uint16_t Lf; DECODE_READ_U16(Lf);
			uint8_t Ns = DECODE_READ_U8;
			if (Ns >= MAX_COMPONENTS) { 
				std :: cerr << "Not supported more than " << MAX_COMPONENTS << " components: s=" << Ns << "\n";
				return DECODE_RESULT_ERR;
			}
			LaneInfo lane_infos[MAX_LANE_COUNT];
			u8 lane_indexes[MAX_COMPONENTS];
			u8 lanes_count = 0;
			for (uint8_t i = 0; i < Ns; ++i) {
				uint8_t C = DECODE_READ_U8;
				if (C >= MAX_COMPONENTS) {
					std :: cerr << "Not supported more than " << MAX_COMPONENTS << " components: cs=" << C << "\n";
					return DECODE_RESULT_ERR;
				}
				auto& component_data = context.component_data[C];
				DECODE_READ_U4(component_data.dc_entropy_table, component_data.ac_entropy_table);
				lane_indexes[i] = lanes_count;
				for (u8 y = 0; y < component_data.sampling_factor_y; ++y) {
					for (u8 x = 0; x < component_data.sampling_factor_x; ++x) {
						lane_infos[lanes_count] = LaneInfo{
							.c_id = C,
							.dc_huf = component_data.dc_entropy_table,
							.ac_huf = component_data.ac_entropy_table,
							.y = y,
							.x = x,
						};
						++lanes_count;
					}
				}
			}
			if (!context.updateLaneIndexes(lane_indexes)) { return DECODE_RESULT_ERR; }
			if (!context.updateLaneInfos(lane_infos)) { return DECODE_RESULT_ERR; }
			uint8_t Ss = DECODE_READ_U8;
			uint8_t Se = DECODE_READ_U8;
			uint8_t Ah, Al; DECODE_READ_U4(Ah, Al);
			
			// decode
			u8* payload = context.payload;
			CLContext<DECODE> cl = context.cl;
			using      decodeHuffman1Args = CLContext<DECODE> :: Kernels ::      decodeHuffman1Args;
			using         decodeRaiseArgs = CLContext<DECODE> :: Kernels ::         decodeRaiseArgs;
			using         decodeLowerArgs = CLContext<DECODE> :: Kernels ::         decodeLowerArgs;
			using  positionsToIndexesArgs = CLContext<DECODE> :: Kernels ::  positionsToIndexesArgs;
			using      decodeHuffman2Args = CLContext<DECODE> :: Kernels ::      decodeHuffman2Args;
			using initializeBufferU32Args = CLContext<DECODE> :: Kernels :: initializeBufferU32Args;
			
			// load payload
			u32 payload_length = 0;
			for (bool running = true; running; ++payload_length) {
				uint8_t x = DECODE_READ_U8;
				if (x == 0xFF) {
					uint8_t marker = DECODE_READ_U8;
					if (marker == 0x00) {
						// go on
					} else if (Marker :: isRST(marker)) {
						return DECODE_RESULT_ERR;
						//	RESET_SCAN_CONTEXT();
						break;
					} else {
						index -= 2;
						running = false;
						break;
					}
				} 
				payload[payload_length] = x;
			}
			for (int i = 0; i < 100; ++i) {
				payload[payload_length+i] = ~0;
			}
			u32 job_size = payload_length * 8;

			// init buffers 
			if (!cl.buffer.payload.write(cl.queue, payload, payload_length)) { return DECODE_RESULT_ERR; }
			if (!cl.kernel.initializeBufferU32.setArg((u32)~0         , initializeBufferU32Args :: value )) { return DECODE_RESULT_ERR; }
			if (!cl.kernel.initializeBufferU32.setArg(cl.buffer.lanes, initializeBufferU32Args :: buffer)) { return DECODE_RESULT_ERR; }
			if (!cl.kernel.initializeBufferU32(cl.queue, 1, &cl.buffer.lanes.length)) { return DECODE_RESULT_ERR; }
			if (!cl.kernel.initializeBufferU32.setArg(cl.buffer.positions, initializeBufferU32Args :: buffer)) { return DECODE_RESULT_ERR; }
			if (!cl.kernel.initializeBufferU32(cl.queue, 1, &cl.buffer.positions.length)) { return DECODE_RESULT_ERR; }
			
			// start kernels
			size_t decodeHuffman1_dim[2] = { Ns, job_size };
			if (!cl.kernel.decodeHuffman1.setArg(payload_length, decodeHuffman1Args :: B2        )) { return DECODE_RESULT_ERR; }
			if (!cl.kernel.decodeHuffman1.setArg(job_size      , decodeHuffman1Args :: lane_width)) { return DECODE_RESULT_ERR; }
			if (!cl.kernel.decodeHuffman1(cl.queue, 2, decodeHuffman1_dim)) { return DECODE_RESULT_ERR; }
			
			// copy from done lanes to lanes with same component
			for (uint8_t i = 0; i < Ns; ++i) {
				auto li = lane_indexes[i];
				auto first_lane = lane_infos[li];
				auto C = first_lane.c_id;
				auto& component_data = context.component_data[C];
				u8 k = 0;
				for (u8 y = 0; y < component_data.sampling_factor_y; ++y) {
					for (u8 x = 0; x < component_data.sampling_factor_x; ++x) {
						if (k == 0) { ++k; continue; }
						size_t a = li * job_size;
						size_t b = a + k++ * job_size;
						if (!cl.buffer.lanes.copy(cl.queue, job_size, a, cl.buffer.lanes, b)) { return DECODE_RESULT_ERR; }
					}
				}
			}
			
			if (!cl.kernel.decodeRaise.setArg(job_size   , decodeRaiseArgs :: lane_width )) { return DECODE_RESULT_ERR; }
			if (!cl.kernel.decodeRaise.setArg(lanes_count, decodeRaiseArgs :: lanes_count)) { return DECODE_RESULT_ERR; }
			u8 depth = 1;
			u32 every_nth = 1;
			std :: cout << (u32)depth << " " << (u32)lanes_count << " " << (u32)job_size << std :: endl;
			for (; true; ++depth) {
				std :: cout << "bbx 0 " << (u32)depth << "!" << std :: endl;
				if (lanes_count % (every_nth * 2) == 0) { every_nth *= 2; }
				size_t decodeRaise_dim[2] = {lanes_count / every_nth, job_size };
				u8 prev_depth = depth - 1;
				if (!cl.kernel.decodeRaise.setArg(prev_depth, decodeRaiseArgs :: prev_size_pow)) { return DECODE_RESULT_ERR; }
				if (!cl.kernel.decodeRaise(cl.queue, 2, decodeRaise_dim)) { return DECODE_RESULT_ERR; }
				//	u32* ns = new u32[cl.buffer.lanes.length];
				//	if (!cl.buffer.lanes.read(cl.queue, ns, cl.buffer.lanes.length)) { return DECODE_RESULT_ERR; }
				//	for (size_t i = 0; i < cl.buffer.lanes.length;)
				//	{
				//		for (int j = 0; j < lanes_count && i < cl.buffer.lanes.length; ++j) {
				//			for (int k = 0; k < job_size && i < cl.buffer.lanes.length; ++k, ++i) {
				//				if (ns[i] != ~0) { std :: cout << ns[i] << " "; }
				//				else { std :: cout << "x" << " "; }
				//			}
				//			std :: cout << std :: endl;
				//		}
				//		std :: cout << std :: endl;
				//	}
				//	std :: cout << std :: endl;
				//	u32 ns[10];
				//	if (!cl.buffer.lanes.read(cl.queue, ns, 10, 188448)) { return DECODE_RESULT_ERR; }
				//	for (size_t i = 0; i < 10; i++)
				//	{
				//		if (ns[i] != ~0) { std :: cout << ns[i] << " "; }
				//		else { std :: cout << "x" << " "; }
				//	}
				//	std :: cout << std :: endl;
				
				
				u32 n;
				if (!cl.buffer.lanes.read(cl.queue, &n, 1, depth * lanes_count * job_size)) { return DECODE_RESULT_ERR; }
				//	std :: cout << "@ " << (depth * lanes_count * job_size) << " = " << std :: hex << n << std :: endl;
				if (n == ~0) {
					break;
				}
			}
			std :: cout << depth << std :: endl;
			u32 zero = 0;
			cl.buffer.positions.write(cl.queue, &zero, 1);
			//	return DECODE_RESULT_ERR;
			
			if (!cl.kernel.decodeLower.setArg(job_size   , decodeLowerArgs :: lane_width )) { return DECODE_RESULT_ERR; }
			if (!cl.kernel.decodeLower.setArg(lanes_count, decodeLowerArgs :: lanes_count)) { return DECODE_RESULT_ERR; }
			for (; depth-- > 0;) {
				if (lanes_count % (4 << depth) == 0) { every_nth /= 2; }
				std :: cout << "bbx 1 " << (u32)depth << " " << (u32) every_nth << "!" << std :: endl;
				size_t decodeLower_dim[2] = {lanes_count / every_nth, job_size };
				if (!cl.kernel.decodeLower.setArg(depth, decodeLowerArgs :: size_pow)) { return DECODE_RESULT_ERR; }
				if (!cl.kernel.decodeLower(cl.queue, 2, decodeLower_dim)) { return DECODE_RESULT_ERR; }
			}
			//	return DECODE_RESULT_ERR;
			
			size_t positionsToIndexes_dim[2] = {lanes_count, job_size};
			if (!cl.kernel.positionsToIndexes.setArg(job_size, positionsToIndexesArgs :: lane_width)) { return DECODE_RESULT_ERR; }
			if (!cl.kernel.positionsToIndexes(cl.queue, 2, positionsToIndexes_dim)) { return DECODE_RESULT_ERR; }
			
			if (!cl.kernel.decodeHuffman2.setArg(job_size, decodeHuffman2Args :: lane_width)) { return DECODE_RESULT_ERR; }
			if (!cl.kernel.decodeHuffman2(cl.queue, 1, &cl.img_size)) { return DECODE_RESULT_ERR; }
			
			if (!plusScanCoefficients(cl.img_size, cl)) { return DECODE_RESULT_ERR; }
			
			//	RESET_SCAN_CONTEXT();
			
			//	bool in_payload = true;
			//	uint8_t b1 = 0;
			//	uint32_t B2 = 0;
			//	while (in_payload) {
			//		load:; {
			//			for (; B2 < RECOMMENDED_SPACE; ++B2) {
			//				uint8_t x = DECODE_READ_U8;
			//				if (x == 0xFF) {
			//					uint8_t marker = DECODE_READ_U8;
			//					if (marker == 0x00) {
			//						// go on
			//					} else if (Marker :: isRST(marker)) {
			//						RESET_SCAN_CONTEXT();
			//						break;
			//					} else {
			//						index -= 2;
			//						in_payload = false;
			//						break;
			//					}
			//				} 
			//				payload[B2] = x;
			//			}
			//		}
			//		// decode
			//		decode:; {
			//			uint32_t bb2 = 8 * B2;
					
			//			// call GPU kernels for each bit
					
			//			for (int ci = 0; ci < Ns; ++ci) {
			//				uint8_t C = component_order[ci];
			//				auto data = context.component_data[C];
			//				auto& hdc = context.huffman_tree[0][data.dc_entropy_table];
			//				auto& hac = context.huffman_tree[1][data.ac_entropy_table];
			//				for (int i = 0; i < data.sampling_factor_y; ++i) {
			//					for (int j = 0; j < data.sampling_factor_x; ++j) {
			//						// decode DC
			//						// u16 code word = a<<(b1+8) | b<<b1 | c<<(b1-8)
			//						// use Huffman
			//						// check that b1 + length + additional bits did not exceed bb2
			//						// consume additional bits
			//						// move b1
								
			//						// decode 63 ACs
			//						for (uint8_t decoded_acs = 0; decoded_acs < 63; ) {
			//							// u16 code word = a<<(b1+8) | b<<b1 | c<<(b1-8)
			//							// use Huffman
			//							// check that b1 + length + additional bits did not exceed bb2
			//							// consume additional bits
			//							// move b1
			//						}
			//					}
			//				}
			//			}
			//		}
			//		// auto B3b3 = cleanPayloadSerial(context, b1, B2);
			//		// b1 = B3b3 % 8;
			//		// auto B3 = B3b3 / 8;
			//		// B2 -= B3;
			//		// // copy undecoded to start
			//		// // might be a problem because memcpy shouldn't be called with the same buffer
			//		// memcpy(&payload[0], &payload[B3], B2);
			//	}
			
			
			// handle MCUs, RST, 0xFF00, ...
			// in MCUs there is DC, AC, components, (non)interleaving
			
			// sadly, i think that, if there is RST, we can only decode up to it, and not more
			// or, we can just throw out trailing 1111
			// but that would take a lot of work (shifting and all)
			return DECODE_RESULT_OK;
		}
		
		namespace {
			#define DO_SCAN_ON_CPU_TRESHOLD 0
			//	#define DO_SCAN_ON_CPU_TRESHOLD 6
			bool plusScanCoefficients(size_t n, CLContext<DECODE> cl) {
				using  prescan1Args = CLContext<DECODE> :: Kernels ::  prescan1Args;
				using  prescan2Args = CLContext<DECODE> :: Kernels ::  prescan2Args;
				using shiftLeftArgs = CLContext<DECODE> :: Kernels :: shiftLeftArgs;
				
				size_t offset = 0;
				i16 start_value = 0;
				for (int max_size_pow = std :: bit_width(n); max_size_pow >= DO_SCAN_ON_CPU_TRESHOLD; --max_size_pow) {
					size_t bit = 1 << max_size_pow;
					if ((bit & n) == 0) { continue; }
					
					//	TODO do plusscan on bit elements from offset 
					for (i8 half_step_pow = 0; half_step_pow < max_size_pow; ++half_step_pow) {
						size_t amount_of_work = bit >> (half_step_pow + 1);
						if (!cl.kernel.prescan1.setArg(half_step_pow, prescan1Args :: half_step_pow)) { return false; }
						if (!cl.kernel.prescan1(cl.queue, 1, &amount_of_work, &offset)) { return false; }
					}
					i16 x;
					if (!cl.buffer.coefficients.read (cl.queue, &x          , 0, offset + bit - 1, sizeof(i16), 0)) { return false; }
					if (!cl.buffer.coefficients.write(cl.queue, &start_value, 0, offset + bit - 1, sizeof(i16), 0)) { return false; }
					start_value += x;
					for (i8 half_step_pow = max_size_pow - 1; half_step_pow > 0; --half_step_pow) {
						size_t amount_of_work = bit >> (half_step_pow + 1);
						if (!cl.kernel.prescan2.setArg(half_step_pow, prescan2Args :: half_step_pow)) { return false; }
						if (!cl.kernel.prescan2(cl.queue, 1, &amount_of_work, &offset)) { return false; }
					}
					size_t amount_of_work = bit - 1;
					if (!cl.kernel.shiftLeft(cl.queue, 1, &amount_of_work, &offset)) { return false; }
					if (!cl.buffer.coefficients.write(cl.queue, &start_value, 0, offset + bit - 1, sizeof(i16), 0)) { return false; }
					
					n -= bit; //	equivalent to seting max_size_pow-th bit to zero
					offset += bit;
				}
				//	TODO remaining n elements manually
				
				return true;
			}
		}
		// void resetScanContext(Context<CodingType :: DECODE>& context) {
		// }
		// i should move this/these into separate file
		// uint32_t cleanPayloadSerial(ref<DecodeContext> context, uint8_t b1, uint32_t B2) {
		// 	// decode from bits [b1] to [8*B2]
		// 	uint8_t* payload = context.payload;
		// }
		
		#ifdef TESTING
		namespace {
			struct Test_plusScanCoefficients : Test {
				virtual char const* getDescription() { return "Test_plusScanCoefficients"; }
				virtual bool test() {
					constexpr int const n = 10;
					Resource<CLContext<DECODE>> cl(1, n);
					i16 coefficients[n][64] = {{3}, {1}, {4}, {1}, {5}, {9}, {2}, {6}, {3}, {1}, };
					i16 expected    [n][64] = {{3}, {4}, {8}, {9}, {14}, {23}, {25}, {31}, {34}, {35}, };
					i16 result      [n][64];
					if (cl.buffer.coefficients.length != n) {
						Test :: getError() << "Invalid size: expected " << n << ", got " << cl.buffer.coefficients.length << std :: endl;
						return false;
					}
					if (!cl.buffer.coefficients.write(cl.queue, coefficients)) { return false; }
					plusScanCoefficients(n, cl);
					if (!cl.buffer.coefficients.read(cl.queue, result)) { return false; }
					
					for (int i = 0; i < n; ++i) {
						if (result[i][0] != expected[i][0]) {
							Test :: getError() << "Difference at index " << i << ": expected " << expected[i][0] << ", got " << result[i][0] << std :: endl;
							return false;
						}
					}
					return true;
				}
			};
			Test_plusScanCoefficients test_plusScanCoefficients;
		}
		#endif
	}
}