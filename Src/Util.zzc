#pragma region zzc cpp
	#if 0
		#define BJPEG_DEBUG_ALL
		#define BJPEG_IF_DEBUG_ALL(...) __VA_ARGS__
		#define BJPEG_IF_NOT_DEBUG_ALL(...) 
	#else
		#define BJPEG_IF_DEBUG_ALL(...) 
		#define BJPEG_IF_NOT_DEBUG_ALL(...) __VA_ARGS__
	#endif
#pragma endregion zzc

#include <concepts>
#include <cstdint>
#include <CL/cl.h>
#include <type_traits>
#include <ostream>

#include "./Resource.zzh"
#include "./Flatten.zzh"

template <typename T>
using ref = T&;
template <typename T>
using rref = T&&;


#pragma region zzc hdr_decl
	#define MAX_COMPONENTS 4
	#define RECOMMENDED_SPACE (1 << recomended_space_pow)

	#define MAX_MCU_LENGTH 10
	#define MAX_LANE_WIDTH (8 * RECOMMENDED_SPACE)
	#define MAX_LANE_ROW_WIDTH (MAX_MCU_LENGTH * MAX_LANE_WIDTH)
	#define MAX_LANE_SIZE (MAX_LANE_ROW_WIDTH * recomended_space_pow)
	#define MAX_UNITS_IN_RECOMMENDED_SPACE (4 * RECOMMENDED_SPACE) // min unit size = 1 dc + EOB = 2 bits
	
	#define ROUND_UP_8(x) ((x + 7) & ~7)
	
	//	defers execution of a code block.
	//	It can use variables declared before it.
	//	defer {/* code */};
	#define defer _DeferVar _defer_macro1(__COUNTER__)
	#define _defer_macro1(cnt) _defer_macro2(cnt)
	#define _defer_macro2(cnt) const tmp_defer_var_ ## cnt = [&] noexcept
	template <typename F> requires (std::is_nothrow_invocable_v<F>)
	struct _DeferVar {
		F f;
		fun inline _DeferVar(F f) : f(f) {}
		fun inline ~_DeferVar() {
			f();
		}
	};
	
	#define clog(fmt, ...) printf(fmt "\n", ## __VA_ARGS__); fflush(stdout);
	#define log(...) std :: cout << __VA_ARGS__ << std :: endl;
#pragma endregion zzc

template <typename E>
concept ScopedEnum = std :: is_scoped_enum_v<E>;


namespace BJpeg {
	enum CodingType { DECODE, ENCODE };
	
	typedef cl_uchar  u8;
	typedef cl_ushort u16;
	typedef cl_uint   u32;
	typedef cl_ulong  u64;
	typedef cl_uchar2 u8x2;
	typedef cl_uint2  u32x2;
	typedef cl_char  i8;
	typedef cl_short i16;
	typedef cl_int   i32;
	typedef cl_long  i64;
	typedef cl_int2  i32x2;
	typedef cl_float f32;
	
	extern u8 recomended_space_pow;
	
	template <typename T> struct ArrayWithLength {
		size_t length = 0; T* array = nullptr;
		fun bool init(size_t length) {
			self.length = length;
			self.array = new T[length];
			return self.array != nullptr;
		}
		void finish() noexcept {
			delete[] self.array;
			self.array = nullptr;
			self.length = 0;
		}
		fun T& operator [](int index) const { return self.array[index]; }
		
		fun operator bool() const noexcept {
			return self.array != nullptr && self.length > 0;
		}
	};
}


fun void* operator new(size_t size) /* noexcept */ { return std :: malloc(size); }
	//	my implementation is `noexcept`, but stdlib declares it as `throws(std::bad_alloc)`
	//	so I can't redeclare differently

#if defined MAIN_TARGET_DECODE || defined MAIN_TARGET_ENCODE || defined TESTING
	
	template<typename T, size_t N> requires (!std :: same_as<T, char> && !std :: same_as<T, char const>)
	fun std :: ostream& operator <<(std :: ostream& stream, T (&arr)[N]) {
		stream << "[ ";
		for (auto& x : arr) { stream << x << ", "; }
		stream << " ]";
		return stream;
	}
	
#endif




fun std :: ostream& operator <<(std :: ostream& s, BJpeg :: i8 x) { return s << (BJpeg :: i32) x; }
fun std :: ostream& operator <<(std :: ostream& s, BJpeg :: u8 x) { return s << (BJpeg :: u32) x; }
