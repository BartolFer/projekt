#ifdef TESTING
#include "./Util.zzh"
#pragma region zzc hdr_decl
	#include <cstdint>
	#include "./Test.zzh"
	#include "./kernels.cl.tmp.zzh"
#pragma endregion zzc
#pragma region zzc src_decl
	#include <iostream>
	#include <vector>
	#include "./MyOpenCL.zzh"
	#include "./Huffman.zzh"
	#include "./Context.zzh"
#pragma endregion zzc


#define PRINT_ARRAY_10(arr) "["\
	<< ((arr)[0]) << ", " \
	<< ((arr)[1]) << ", " \
	<< ((arr)[2]) << ", " \
	<< ((arr)[3]) << ", " \
	<< ((arr)[4]) << ", " \
	<< ((arr)[5]) << ", " \
	<< ((arr)[6]) << ", " \
	<< ((arr)[7]) << ", " \
	<< ((arr)[8]) << ", " \
	<< ((arr)[9]) << ", " \
<< "]"

#define PRINT_X_MATRIX(mat, h, w) {                         \
    for (int i = 0; i < (w); ++i) { printf(" %2d", i); }    \
    printf("\n");                                           \
    for (int i = 0; i < (h); ++i) {                         \
        for (int j = 0; j < (w); ++j) {                     \
            u32 v = (mat)[i][j];                            \
            if (v == x) { printf("  x"); }                 \
            else        { printf(" %2u", v); }              \
        }                                                   \
        printf("\n");                                       \
    }                                                       \
}

namespace BJpeg {
	namespace {
		Kernels kernels_var;
		
		template <typename T>
		struct Arr64 { 
			T arr[64]; 
			fun inline T& operator [](int i) { return self.arr[i]; }
		};
		
		fun std :: vector<Arr64<i32>> inflateTo64Coefficients(std :: vector<i32> dc_coefficients) {
			std :: vector<Arr64<i32>> result; result.resize(dc_coefficients.size());
			int index = 0;
			for (int index = 0; index < dc_coefficients.size(); ++index) {
				result[index][0] = dc_coefficients[index];
				for (int i = 1; i < 64; ++i) {
					result[index][i] = i;
					//	or any random value (but consistent between calls (we want that coefficients and expected have same ACs (in prefixSum test)))
				}
			}
			return result;
		}
		
		struct KernelsTest : Test {
			fun virtual bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) = 0;
			fun virtual bool test() {
				cl_device_id device_id;
				if (!MyOpenCL :: getDeviceId(device_id)) { return false; }
				
				Resource<MyOpenCL :: Context> context(device_id);               if (!context) { return false; }
				Resource<MyOpenCL :: Queue>   queue(device_id, context);        if (!queue  ) { return false; }
				Resource<MyOpenCL :: Program> program(device_id, context, BJpeg::kernels); if (!program) { return false; }
				
				return self.kernelTest(context, queue, program);
			}
		};
		
		struct BufferSetter {
			MyOpenCL :: Kernel<1> kernel;
			fun bool init(MyOpenCL :: Program program) { return self.kernel.init(program, "initializeBufferU32"); }
			fun void finish() noexcept { self.kernel.finish(); }
			fun bool operator ()(MyOpenCL :: Queue queue, MyOpenCL :: Buffer<uint32_t> buffer, uint32_t value) {
				self.kernel.resetArgs();
				if (!self.kernel.setArg(buffer)) { return false; }
				if (!self.kernel.setArg(value)) { return false; }
				
				if (!self.kernel(queue, &buffer.length)) { return false; }
				return true;
			}
		};
		struct Test_decodeHuffman1 : KernelsTest {
			fun char const* getDescription() { return "Test decodeHuffman1"; }
			fun bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.decodeHuffman1, program);
				if (!kernel) { return false; }
				
				constexpr uint32_t const B2 = 14;
				constexpr uint32_t const lane_width = 128;
				constexpr uint8_t const lanes_count = 3;
				constexpr uint8_t const depth = 5;
				constexpr uint8_t  const prev_size_pow = 0;
				uint32_t const x = ~(uint32_t)0;
				
				HuffmanTree trees_arr[2][4] = {
					{
						{.nodes={{1, 4}, {2, 3}, {0, 3}, {0, 6}, {5, 8}, {6, 7}, {0, 7}, {0, 4}, {9, 10}, {0, 5}, {11, 12}, {0, 2}, {1, 0}}},
						{.nodes={{1, 2}, {0, 2}, {3, 4}, {0, 5}, {5, 6}, {0, 4}, {7, 8}, {0, 3}, {1, 0}}},
					},
					{
						{.nodes={{1, 14}, {2, 5}, {3, 4}, {0, 213}, {0, 149}, {6, 9}, {7, 8}, {0, 0}, {0, 197}, {10, 11}, {0, 20}, {12, 13}, {0, 5}, {0, 85}, {15, 34}, {16, 23}, {17, 20}, {18, 19}, {0, 212}, {0, 164}, {21, 22}, {0, 133}, {0, 147}, {24, 27}, {25, 26}, {0, 69}, {0, 228}, {28, 31}, {29, 30}, {0, 4}, {0, 148}, {32, 33}, {0, 53}, {0, 21}, {35, 58}, {36, 43}, {37, 40}, {38, 39}, {0, 99}, {0, 3}, {41, 42}, {0, 67}, {0, 131}, {44, 51}, {45, 48}, {46, 47}, {0, 84}, {0, 100}, {49, 50}, {0, 244}, {0, 180}, {52, 55}, {53, 54}, {0, 181}, {0, 196}, {56, 57}, {0, 229}, {0, 245}, {59, 74}, {60, 67}, {61, 64}, {62, 63}, {0, 227}, {0, 195}, {65, 66}, {0, 179}, {0, 68}, {68, 71}, {69, 70}, {0, 116}, {0, 243}, {72, 73}, {0, 115}, {0, 35}, {75, 82}, {76, 79}, {77, 78}, {0, 51}, {0, 37}, {80, 81}, {0, 211}, {0, 83}, {83, 90}, {84, 87}, {85, 86}, {0, 101}, {0, 52}, {88, 89}, {0, 117}, {0, 165}, {91, 94}, {92, 93}, {0, 240}, {0, 36}, {95, 98}, {96, 97}, {0, 163}, {0, 19}, {99, 100}, {0, 132}, {1, 0}}},
						{.nodes={{1, 12}, {2, 5}, {3, 4}, {0, 99}, {0, 116}, {6, 9}, {7, 8}, {0, 243}, {0, 240}, {10, 11}, {0, 244}, {0, 164}, {13, 28}, {14, 19}, {15, 16}, {0, 179}, {17, 18}, {0, 131}, {0, 67}, {20, 23}, {21, 22}, {0, 36}, {0, 35}, {24, 25}, {0, 100}, {26, 27}, {0, 115}, {0, 52}, {29, 44}, {30, 37}, {31, 34}, {32, 33}, {0, 212}, {0, 227}, {35, 36}, {0, 20}, {0, 132}, {38, 41}, {39, 40}, {0, 228}, {0, 0}, {42, 43}, {0, 196}, {0, 195}, {45, 52}, {46, 49}, {47, 48}, {0, 83}, {0, 4}, {50, 51}, {0, 51}, {0, 84}, {53, 58}, {54, 55}, {0, 148}, {56, 57}, {0, 211}, {0, 68}, {59, 62}, {60, 61}, {0, 3}, {0, 180}, {63, 66}, {64, 65}, {0, 163}, {0, 19}, {67, 68}, {0, 147}, {1, 0}}},
					},
				};
				uint8_t payload_arr[] = {237, 195, 199, 49, 126, 100, 208, 114, 185, 102, 90, 179, 218, 255, 255, 255};
				LaneInfo lane_infos_arr[lanes_count] = {{.dc_huf=0, .ac_huf=0}, {.dc_huf=0, .ac_huf=0}, {.dc_huf=1, .ac_huf=1}, };

				uint32_t initial[depth][lanes_count][lane_width] = {
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
				};
				uint32_t result  [depth][lanes_count][lane_width] = {{{0}}};
				uint8_t lane_indexes_arr[2] = {0, 2};
				
				Resource<MyOpenCL :: Buffer<uint8_t>> payload(context, CL_MEM_READ_ONLY, sizeof(payload_arr));
				if (!payload) { return false; }
				if (!payload.write(queue, payload_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<HuffmanTree[4]>> trees(context, CL_MEM_READ_ONLY, 2);
				if (!trees) { return false; }
				if (!trees.write(queue, trees_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<LaneInfo>> lane_infos(context, CL_MEM_READ_ONLY, lanes_count);
				if (!lane_infos) { return false; }
				if (!lane_infos.write(queue, lane_infos_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<uint32_t>> lanes(context, CL_MEM_READ_WRITE, depth * lanes_count * lane_width);
				if (!lanes) { return false; }
				if (!lanes.write(queue, &initial[0][0][0])) { return false; }
				Resource<MyOpenCL :: Buffer<uint8_t>> lane_indexes(context, CL_MEM_READ_ONLY, 2);
				if (!lane_indexes) { return false; }
				if (!lane_indexes.write(queue, &lane_indexes_arr[0])) { return false; }
				
				if (!kernel.setArg_payload     (payload     )) { return false; }
				if (!kernel.setArg_B2          (B2          )) { return false; }
				if (!kernel.setArg_trees       (trees       )) { return false; }
				if (!kernel.setArg_lane_infos  (lane_infos  )) { return false; }
				if (!kernel.setArg_lanes       (lanes       )) { return false; }
				if (!kernel.setArg_lane_width  (lane_width  )) { return false; }
				if (!kernel.setArg_lane_indexes(lane_indexes)) { return false; }
				
				size_t global_work[2] = { 2, 8*B2 };
				if (!kernel(queue, global_work)) { return false; }
				
				if (!lanes.read(queue, &result[0][0][0])) { return false; }
				//	PRINT_X_MATRIX(result[0], lanes_count, lane_width);
				if (result[0][0][0] != 54) {
					Test :: getError() << "[0][0][0]: e=" << 54 << " v=" << result[0][0][0] << std :: endl;
					return false;
				}
				if (result[0][2][54] != 51) {
					Test :: getError() << "[0][2][54]: e=" << 51 << " v=" << result[0][2][54] << std :: endl;
					return false;
				}
				if (result[0][0][54 + 51] != x) {
					Test :: getError() << "[0][0][54 + 51]: e=x=" << x << " v=" << result[0][0][54 + 51] << std :: endl;
					return false;
				}
				
				return true;
			}
		};
		struct Test_decodeRaise : KernelsTest {
			fun char const* getDescription() { return "Test decodeRaise"; }
			fun bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.decodeRaise, program);
				if (!kernel) { return false; }
				
				constexpr uint32_t const lane_width = 64;
				constexpr uint8_t const lanes_count = 4;
				constexpr uint8_t const depth = 5;
				constexpr uint8_t  const prev_size_pow = 0;
				uint32_t const x = ~(uint32_t)0;
				uint32_t initial[depth][lanes_count][lane_width] = {
					{
						{3,2,1,4,3,2,1,x,4,3,2,1,4,3,2,1,3,2,1,2,1,3,2,1,x,4,3,2,1,1,4,3,2,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{3,2,1,4,3,2,1,x,4,3,2,1,4,3,2,1,3,2,1,2,1,3,2,1,x,4,3,2,1,1,4,3,2,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{3,2,1,4,3,2,1,5,4,3,2,1,4,3,2,1,3,2,1,2,1,3,2,1,5,4,3,2,1,1,4,3,2,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{3,3,2,4,3,3,2,5,4,3,3,2,4,3,3,2,3,3,2,3,2,3,3,2,5,4,3,3,2,2,4,3,3,2,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
				};
				uint32_t result  [depth][lanes_count][lane_width] = {{{0}}};
				uint32_t expected[depth][lanes_count][lane_width] = {
					{
						{3,2,1,4,3,2,1,x,4,3,2,1,4,3,2,1,3,2,1,2,1,3,2,1,x,4,3,2,1,1,4,3,2,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{3,2,1,4,3,2,1,x,4,3,2,1,4,3,2,1,3,2,1,2,1,3,2,1,x,4,3,2,1,1,4,3,2,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{3,2,1,4,3,2,1,5,4,3,2,1,4,3,2,1,3,2,1,2,1,3,2,1,5,4,3,2,1,1,4,3,2,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{3,3,2,4,3,3,2,5,4,3,3,2,4,3,3,2,3,3,2,3,2,3,3,2,5,4,3,3,2,2,4,3,3,2,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{7,6,5,x,x,x,x,x,8,7,6,5,7,6,5,4,5,4,3,5,4,x,x,x,x,5,4,3,2,5,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{7,6,5,9,8,7,6,9,8,7,6,5,7,6,5,4,6,5,4,5,4,8,7,6,7,6,5,4,3,5,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
				};
				
				Resource<MyOpenCL :: Buffer<uint32_t>> lanes(context, CL_MEM_READ_WRITE, depth * lanes_count * lane_width);
				if (!lanes) { return false; }
				if (!lanes.write(queue, &initial[0][0][0])) { return false; }
				
				if (!kernel.setArg_lanes(lanes)) { return false; }
				if (!kernel.setArg_lane_width(lane_width)) { return false; }
				if (!kernel.setArg_lanes_count(lanes_count)) { return false; }
				if (!kernel.setArg_prev_size_pow(prev_size_pow)) { return false; }
				
				size_t global_work[2] = { 2, lane_width };
				if (!kernel(queue, global_work)) { return false; }
				
				if (!lanes.read(queue, &result[0][0][0])) { return false; }
				for (uint32_t d = 0; d < depth; ++d) {
					for (uint32_t l = 0; l < lanes_count; ++l) {
						for (uint32_t i = 0; i < lane_width; ++i) {
							if (result[d][l][i] != expected[d][l][i]) {
								Test :: getError() << "[" << d << "][" << l << "][" << i << "]: e=" << expected[d][l][i] << " v=" << result[d][l][i] << std :: endl;
								return false;
							}
						}
					}
				}
				
				return true;
			}
		};
		struct Test_decodeLower : KernelsTest {
			fun char const* getDescription() { return "Test decodeLower"; }
			fun bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.decodeLower, program);
				if (!kernel) { return false; }
				Resource<BufferSetter> set_buf(program);
				if (!set_buf) { return false; }
				
				constexpr uint32_t const lane_width = 64;
				constexpr uint8_t const lanes_count = 4;
				constexpr uint8_t const depth = 5;
				uint32_t const x = ~(uint32_t)0;
				uint32_t initial[depth][lanes_count][lane_width] = {
					{
						{ 3, 2, 1, 4, 3, 2, 1, x, 4, 3, 2, 1, 4, 3, 2, 1, 3, 2, 1, 2, 1, 3, 2, 1, x, 4, 3, 2, 1, 1, 4, 3, 2, 1, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ 3, 2, 1, 4, 3, 2, 1, x, 4, 3, 2, 1, 4, 3, 2, 1, 3, 2, 1, 2, 1, 3, 2, 1, x, 4, 3, 2, 1, 1, 4, 3, 2, 1, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ 3, 2, 1, 4, 3, 2, 1, 5, 4, 3, 2, 1, 4, 3, 2, 1, 3, 2, 1, 2, 1, 3, 2, 1, 5, 4, 3, 2, 1, 1, 4, 3, 2, 1, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ 3, 3, 2, 4, 3, 3, 2, 5, 4, 3, 3, 2, 4, 3, 3, 2, 3, 3, 2, 3, 2, 3, 3, 2, 5, 4, 3, 3, 2, 2, 4, 3, 3, 2, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
					},
					{
						{ 7, 6, 5, x, x, x, x, x, 8, 7, 6, 5, 7, 6, 5, 4, 5, 4, 3, 5, 4, x, x, x, x, 5, 4, 3, 2, 5, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ 7, 6, 5, 9, 8, 7, 6, 9, 8, 7, 6, 5, 7, 6, 5, 4, 6, 5, 4, 5, 4, 8, 7, 6, 7, 6, 5, 4, 3, 5, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
					},
					{
						{16,15,14, x, x, x, x, x,14,13,12,11,12,11,10, 9,13,12,11,12,11, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
					},
					{
						{29,28,27, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
					},
					{
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
					},
				};
				uint32_t result  [lanes_count][lane_width + 8] = {{{0}}};
				uint32_t expected[lanes_count][lane_width] = {
					{0,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,4,x,x,x,x,x,x,x,x,x,x,x,x,8,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					{x,x,x,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,5,x,x,x,x,x,x,x,x,x,x,9,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					{x,x,x,x,x,x,x,2,x,x,x,x,x,x,x,x,x,x,x,x,x,6,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					{x,x,x,x,x,x,x,x,x,x,x,x,3,x,x,x,x,x,x,x,x,x,x,x,7,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
				};
				
				Resource<MyOpenCL :: Buffer<uint32_t>> positions(context, CL_MEM_READ_WRITE, lanes_count * (lane_width + 8));
				if (!positions) { return false; }
				if (!set_buf(queue, positions, x)) { return false; }
				uint32_t zero = 0;
				if (!positions.write(queue, &zero, 1)) { return false; }
				Resource<MyOpenCL :: Buffer<uint32_t>> lanes(context, CL_MEM_READ_WRITE, depth * lanes_count * lane_width);
				if (!lanes) { return false; }
				if (!lanes.write(queue, &initial[0][0][0])) { return false; }
				
				if (!kernel.setArg_positions  (positions)) { return false; }
				if (!kernel.setArg_lanes      (lanes)) { return false; }
				if (!kernel.setArg_lane_width (lane_width)) { return false; }
				if (!kernel.setArg_lanes_count(lanes_count)) { return false; }
				
				uint8_t size_pow;
				size_t global_work[2] = { lanes_count, lane_width };

				size_pow = 3;
				global_work[0] = 1;
				if (!kernel.setArg_size_pow(size_pow)) { return false; }
				if (!kernel(queue, global_work)) { return false; }
				if (!positions.read(queue, &result[0][0])) { return false; }
				size_pow = 2;
				global_work[0] = 1;
				if (!kernel.setArg_size_pow(size_pow)) { return false; }
				if (!kernel(queue, global_work)) { return false; }
				if (!positions.read(queue, &result[0][0])) { return false; }
				size_pow = 1;
				global_work[0] = 1;
				if (!kernel.setArg_size_pow(size_pow)) { return false; }
				if (!kernel(queue, global_work)) { return false; }
				if (!positions.read(queue, &result[0][0])) { return false; }
				size_pow = 0;
				global_work[0] = 2;
				if (!kernel.setArg_size_pow(size_pow)) { return false; }
				if (!kernel(queue, global_work)) { return false; }
				
				if (!positions.read(queue, &result[0][0])) { return false; }
				for (uint32_t l = 0; l < lanes_count; ++l) {
					for (uint32_t i = 0; i < 34; ++i) { //	hardcoded
						if (result[l][i] != expected[l][i]) {
							Test :: getError() << "[" << l << "][" << i << "]: e=" << expected[l][i] << " v=" << result[l][i] << std :: endl;
							return false;
						}
					}
				}
				
				return true;
			}
		};
		struct Test_positionsToIndexes : KernelsTest {
			fun char const* getDescription() { return "Test positionsToIndexes"; }
			fun bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.positionsToIndexes, program);
				if (!kernel) { return false; }
				Resource<BufferSetter> set_buf(program);
				if (!set_buf) { return false; }
				
				constexpr uint32_t const lane_width = 64;
				constexpr uint8_t const lanes_count = 4;
				constexpr uint8_t const depth = 5;
				uint32_t const x = ~(uint32_t)0;
				
				uint32_t initial[lanes_count][lane_width + 8] = {
					{0,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,4,x,x,x,x,x,x,x,x,x,x,x,x,8,x,x,x,x, x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x, x,x,x,x, x,x,x,x,},
					{x,x,x,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,5,x,x,x,x,x,x,x,x,x,x,9,x,x,x, x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x, x,x,x,x, x,x,x,x,},
					{x,x,x,x,x,x,x,2,x,x,x,x,x,x,x,x,x,x,x,x,x,6,x,x,x,x,x,x,x,x,x,x,x,x,10,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x, x,x,x,x, x,x,x,x,},
					{x,x,x,x,x,x,x,x,x,x,x,x,3,x,x,x,x,x,x,x,x,x,x,x,7,x,x,x,x,x,x,x,x,x, x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x, x,x,x,x, x,x,x,x,},
				};
				cl_uint2 result  [11] = {0};
				cl_uint2 expected[11] = {{{0,0}}, {{1,3}}, {{2,7}}, {{3,12}}, {{0,16}}, {{1,19}}, {{2,21}}, {{3,24}}, {{0,29}}, {{1,30}}, {{2,34}}};
				
				Resource<MyOpenCL :: Buffer<uint32_t>> positions(context, CL_MEM_READ_WRITE, lanes_count * (lane_width + 8));
				if (!positions) { return false; }
				if (!positions.write(queue, &initial[0][0])) { return false; }
				Resource<MyOpenCL :: Buffer<cl_uint2>> indexes(context, CL_MEM_READ_WRITE, 16);
				if (!indexes) { return false; }
				if (!indexes.write(queue, result)) { return false; }
				
				if (!kernel.setArg_positions (positions )) { return false; }
				if (!kernel.setArg_indexes   (indexes   )) { return false; }
				if (!kernel.setArg_lane_width(lane_width)) { return false; }
				
				size_t global_work[2] = { lanes_count, lane_width };
				if (!kernel(queue, global_work)) { return false; }
				if (!indexes.read(queue, &result[0])) { return false; }
				
				for (int i = 0; i <= 10; ++i) {
					if (result[i].s[0] != expected[i].s[0] || result[i].s[1] != expected[i].s[1]) {
						Test :: getError() << "[" << i << "]: e=(" << expected[i].s[0] << "," << expected[i].s[1] << ")" << " v=(" << result[i].s[0] << "," << result[i].s[1] << ")" << std :: endl;
						return false;
					}
				}
				
				return true;
			}
		};
		struct Test_decodeHuffman2 : KernelsTest {
			fun char const* getDescription() { return "Test decodeHuffman2"; }
			fun bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.decodeHuffman2, program);
				if (!kernel) { return false; }
				
				constexpr uint32_t const B2 = 14;
				constexpr uint32_t const lane_width = 128;
				constexpr uint8_t const lanes_count = 3;
				constexpr uint8_t const unit_count = 2;
				constexpr uint8_t const depth = 5;
				uint32_t const x = ~(uint32_t)0;
				
				HuffmanTree trees_arr[2][4] = {
					{
						{.nodes={{1, 4}, {2, 3}, {0, 3}, {0, 6}, {5, 8}, {6, 7}, {0, 7}, {0, 4}, {9, 10}, {0, 5}, {11, 12}, {0, 2}, {1, 0}}},
						{.nodes={{1, 2}, {0, 2}, {3, 4}, {0, 5}, {5, 6}, {0, 4}, {7, 8}, {0, 3}, {1, 0}}},
					},
					{
						{.nodes={{1, 14}, {2, 5}, {3, 4}, {0, 213}, {0, 149}, {6, 9}, {7, 8}, {0, 0}, {0, 197}, {10, 11}, {0, 20}, {12, 13}, {0, 5}, {0, 85}, {15, 34}, {16, 23}, {17, 20}, {18, 19}, {0, 212}, {0, 164}, {21, 22}, {0, 133}, {0, 147}, {24, 27}, {25, 26}, {0, 69}, {0, 228}, {28, 31}, {29, 30}, {0, 4}, {0, 148}, {32, 33}, {0, 53}, {0, 21}, {35, 58}, {36, 43}, {37, 40}, {38, 39}, {0, 99}, {0, 3}, {41, 42}, {0, 67}, {0, 131}, {44, 51}, {45, 48}, {46, 47}, {0, 84}, {0, 100}, {49, 50}, {0, 244}, {0, 180}, {52, 55}, {53, 54}, {0, 181}, {0, 196}, {56, 57}, {0, 229}, {0, 245}, {59, 74}, {60, 67}, {61, 64}, {62, 63}, {0, 227}, {0, 195}, {65, 66}, {0, 179}, {0, 68}, {68, 71}, {69, 70}, {0, 116}, {0, 243}, {72, 73}, {0, 115}, {0, 35}, {75, 82}, {76, 79}, {77, 78}, {0, 51}, {0, 37}, {80, 81}, {0, 211}, {0, 83}, {83, 90}, {84, 87}, {85, 86}, {0, 101}, {0, 52}, {88, 89}, {0, 117}, {0, 165}, {91, 94}, {92, 93}, {0, 240}, {0, 36}, {95, 98}, {96, 97}, {0, 163}, {0, 19}, {99, 100}, {0, 132}, {1, 0}}},
						{.nodes={{1, 12}, {2, 5}, {3, 4}, {0, 99}, {0, 116}, {6, 9}, {7, 8}, {0, 243}, {0, 240}, {10, 11}, {0, 244}, {0, 164}, {13, 28}, {14, 19}, {15, 16}, {0, 179}, {17, 18}, {0, 131}, {0, 67}, {20, 23}, {21, 22}, {0, 36}, {0, 35}, {24, 25}, {0, 100}, {26, 27}, {0, 115}, {0, 52}, {29, 44}, {30, 37}, {31, 34}, {32, 33}, {0, 212}, {0, 227}, {35, 36}, {0, 20}, {0, 132}, {38, 41}, {39, 40}, {0, 228}, {0, 0}, {42, 43}, {0, 196}, {0, 195}, {45, 52}, {46, 49}, {47, 48}, {0, 83}, {0, 4}, {50, 51}, {0, 51}, {0, 84}, {53, 58}, {54, 55}, {0, 148}, {56, 57}, {0, 211}, {0, 68}, {59, 62}, {60, 61}, {0, 3}, {0, 180}, {63, 66}, {64, 65}, {0, 163}, {0, 19}, {67, 68}, {0, 147}, {1, 0}}},
					},
				};
				uint8_t payload_arr[] = {237, 195, 199, 49, 126, 100, 208, 114, 185, 102, 90, 179, 218, 255, 255, 255};
				LaneInfo lane_infos_arr[lanes_count] = {{.dc_huf=0, .ac_huf=0}, {.dc_huf=0, .ac_huf=0}, {.dc_huf=1, .ac_huf=1}, };
				cl_uint2 indexes_arr[unit_count] = {
					{0, 0},
					{2, 54},
				};

				struct {
					uint8_t SSSS;
					uint16_t bits;
				} expected[unit_count][64] = {
					{{2, 0b11}, {5, 0b00011}, {3, 0b110}, {0,0}      , {4, 0b0010}, {0,0}      , {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {3, 0b011}, }, 
					{{2, 0b00}, {4, 0b0101} , {0,0}     , {4, 0b1100}, {0,0}      , {4, 0b1101}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}     , {3, 0b110}, },
				};
					//	1110-11 01110-00011 110001-110 0110-0010 11111100 110010-011 0100
					//	0-00 111001-0101 110010-1100 110010-1101 0101 10011-110 110101
					//	11111111111111111111111
				i32 result_arr[unit_count][64];
				
				Resource<MyOpenCL :: Buffer<uint8_t>> payload(context, CL_MEM_READ_ONLY, sizeof(payload_arr));
				if (!payload) { return false; }
				if (!payload.write(queue, payload_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<HuffmanTree[4]>> trees(context, CL_MEM_READ_ONLY, 2);
				if (!trees) { return false; }
				if (!trees.write(queue, trees_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<LaneInfo>> lane_infos(context, CL_MEM_READ_ONLY, lanes_count);
				if (!lane_infos) { return false; }
				if (!lane_infos.write(queue, lane_infos_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<cl_uint2>> indexes(context, CL_MEM_READ_ONLY, 2);
				if (!indexes) { return false; }
				if (!indexes.write(queue, indexes_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<i32[64]>> result(context, CL_MEM_READ_WRITE, 2);
				if (!result) { return false; }
				
				if (!kernel.setArg_payload     (payload   )) { return false; }
				if (!kernel.setArg_trees       (trees     )) { return false; }
				if (!kernel.setArg_lane_infos  (lane_infos)) { return false; }
				if (!kernel.setArg_lane_width  (lane_width)) { return false; }
				if (!kernel.setArg_indexes     (indexes   )) { return false; }
				if (!kernel.setArg_coefficients(result    )) { return false; }
				
				size_t global_work[1] = { unit_count };
				if (!kernel(queue, global_work)) { return false; }
				
				if (!result.read(queue, result_arr)) { return false; }
				for (int unit_id = 0; unit_id < unit_count; ++unit_id) {
					for (int i = 0; i < 64; ++i) {
						auto ex   = expected  [unit_id][i];
						int16_t r = result_arr[unit_id][i];
						if (ex.SSSS == 0) {
							if (r != 0) {
								Test :: getError() << "[" << unit_id << "][" << i << "]: 0 e=" << ex.SSSS << "|" << ex.bits << " v=" << r << "(" << std::hex << r << ")" << std :: endl;
								return false;
							}
						} else {
							int M = 1 << ex.SSSS;
							int m = M >> 1;
							int mask = M - 1;
							if (m <= r && r < M) {
								if (r & mask != ex.bits) {
									Test :: getError() << "[" << unit_id << "][" << i << "]: + e=" << (u16) ex.SSSS << "|" << std::hex << ex.bits << " v=" << r << "(" << std::hex << r << ")" << std :: endl;
									return false;
								}
							} else if (-M < r && r <= -m) {
								if ((r - 1) & mask != ex.bits) {
									Test :: getError() << "[" << unit_id << "][" << i << "]: - e=" << (u16) ex.SSSS << "|" << std::hex << ex.bits << " v=" << r << "(" << std::hex << r << ")" << std :: endl;
									return false;
								}
							} else {
								Test :: getError() << "[" << unit_id << "][" << i << "]: SSSS e=" << (u16) ex.SSSS << "|" << std::hex << ex.bits << " v=" << r << "(" << std::hex << r << ")" << std :: endl;
								return false;
							}
						}
					}
				}
				
				return true;
			}
		};
		struct Test_prepareMCUs : KernelsTest {
			fun char const* getDescription() { return "Test prepareMCUs"; }
			fun bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.prepareMCUs, program); if (!kernel) { return false; }
				
				//                                                               A  B  B  C
				auto coefficients_arr = inflateTo64Coefficients(std::vector<i32>{25,23,31,23, 31,28,27,27, 10,31,25,25, 18,27,28,29, 29,30,33,33});
				auto expected_arr     = inflateTo64Coefficients(std::vector<i32>{25,23,54,23, 31,28,55,27, 10,31,56,25, 18,27,55,29, 29,30,63,33});
				auto lane_infos_arr = std::vector{LaneInfo{.start_in_mcu = 1, .amount_in_mcu = 2}};
				
				u8 mcu_length = 4;
				size_t work[2] = {1, coefficients_arr.size() / mcu_length};
				
				Resource<MyOpenCL :: Buffer<i32[64]>> coefficients(context, CL_MEM_READ_WRITE, coefficients_arr.size()); if (!coefficients) { return false; }
				Resource<MyOpenCL :: Buffer<LaneInfo>>  lane_infos(context, CL_MEM_READ_WRITE,   lane_infos_arr.size()); if (!  lane_infos) { return false; }
				
				if (!coefficients.write(queue, &coefficients_arr[0].arr)) { return false; }
				if (!  lane_infos.write(queue, &  lane_infos_arr[0])) { return false; }
				
				if (!kernel.setArg_coefficients(coefficients)) { return false; }
				if (!kernel.setArg_lane_infos  (lane_infos  )) { return false; }
				if (!kernel.setArg_mcu_length  (mcu_length  )) { return false; }
				if (!kernel(queue, work)) { return false; }
				
				if (!coefficients.read(queue, &coefficients_arr[0].arr)) { return false; }
				for (int i = 0; i < coefficients_arr.size(); ++i) {
					for (int j = 0; j < 64; ++j) {
						if (coefficients_arr[i][j] != expected_arr[i][j]) {
							Test :: getError() << "Error at " << i << ", " << j << ": Expected " << expected_arr[i][j] << " Got " << coefficients_arr[i][j];
							return false;
						}
					}
				}
				
				return true;
			}
		};
		template <int PrefixId> requires (PrefixId == 1 || PrefixId == 2) struct _PrefixSumKernel    {};
		template <            >                                           struct _PrefixSumKernel<1> { static inline auto kernel = kernels_var.prefixSum1; };
		template <            >                                           struct _PrefixSumKernel<2> { static inline auto kernel = kernels_var.prefixSum2; };
		template <int PrefixId> requires (PrefixId == 1 || PrefixId == 2) auto prefixSum = _PrefixSumKernel<PrefixId> :: kernel;
		template <int PrefixId>
		struct PrefixSumTest : KernelsTest {
			char const* name;
			u8 mcu_length;
			u32 half_size;
			std :: vector<LaneInfo> lane_infos;
			std :: vector<Arr64<i32>> coefficients;
			std :: vector<Arr64<i32>> expected;
			fun inline PrefixSumTest(
				char const* name,
				u8 mcu_length,
				u32 half_size,
				std :: vector<LaneInfo> lane_infos,
				std :: vector<i32> coefficients,
				std :: vector<i32> expected
			) :
				name(name),
				mcu_length(mcu_length),
				half_size(half_size),
				lane_infos(lane_infos),
				coefficients(inflateTo64Coefficients(coefficients)),
				expected(inflateTo64Coefficients(expected))
			{}
			
			fun char const* getDescription() { return self.name; }
			fun bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				#ifdef VSCODE_ONLY
					Resource<typename Kernels::prefixSum1> kernel(kernels_var.prefixSum1, program);
				#else
					Resource kernel(prefixSum<PrefixId>, program); if (!kernel) { return false; }
				#endif
				
				if (self.coefficients.size() != self.expected.size()) { return false; }
				if (self.lane_infos.size() != mcu_length) { return false; }
				if (self.coefficients.size() / 64 % mcu_length != 0) { return false; }
				size_t n = self.coefficients.size() / mcu_length;
				
				Resource<MyOpenCL :: Buffer<i32[64] >> coefficients(context, CL_MEM_READ_WRITE, self.coefficients.size()); if (!coefficients) { return false; }
				Resource<MyOpenCL :: Buffer<LaneInfo>> lane_infos  (context, CL_MEM_READ_WRITE, self.lane_infos  .size()); if (!lane_infos  ) { return false; }
				
				if (!coefficients.write(queue, &self.coefficients[0].arr)) { return false; }
				if (!lane_infos  .write(queue, &self.lane_infos  [0])) { return false; }
				
				if (!kernel.setArg_coefficients(coefficients)) { return false; }
				if (!kernel.setArg_lane_infos  (lane_infos  )) { return false; }
				if (!kernel.setArg_half_size   (half_size   )) { return false; }
				if (!kernel.setArg_mcu_length  (mcu_length  )) { return false; }
				
				size_t amount[1] = {n / (2 * half_size)};
				if (!kernel(queue, amount)) { return false; }
				
				if (!coefficients.read(queue, &self.coefficients[0].arr)) { return false; }
				for (int i = 0; i < self.coefficients.size(); ++i) {
					for (int j = 0; j < 64; ++j) {
						if (self.coefficients[i][j] != self.expected[i][j]) {
							Test :: getError() << "Error at " << i << ", " << j << ": Expected " << self.expected[i][j] << " Got " << self.coefficients[i][j];
							return false;
						}
					}
				}
				
				return true;
			}
		};
		struct Test_uninterleave_upsample : KernelsTest {
			fun char const* getDescription() { return "Test uninterleave_upsample"; }
			fun bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.uninterleave_upsample, program); if (!kernel) { return false; }
				
				constexpr u8 mcu_length = 4;
				constexpr u8 Y = 6;
				constexpr u8 X = 4;
				constexpr u8 SF_Y = 2;
				constexpr u8 SF_X = 1;
				constexpr u8x2 max_sf = {1, 2};
				constexpr u32x2 image_size = {X*8, Y*8};
				constexpr u32 mcu_per_line = X/SF_X;
				constexpr u8 component_count = 3;
				constexpr i32 SENTINEL = 0xDD;
				static_assert(Y % SF_Y == 0);
				static_assert(X % SF_X == 0);
				size_t work[2] = {Y/SF_Y, X/SF_X};
				//	AABC
				//	6x4 units (40x32)
				//	A1 B c   A1 B c
				//	A2 B c   A2 B c
				float coefficients_arr[Y/SF_Y * X/SF_X * mcu_length][64] = {
					{0xA0}, {0xA1}, {0xB2}, {0xC3},   {0xA4}, {0xA5}, {0xB6}, {0xC7},   {0xA8}, {0xA9}, {0xBA}, {0xCB},   {0xAC}, {0xA0}, {0xB1}, {0xC2},   
					{0xA3}, {0xA4}, {0xB5}, {0xC6},   {0xA7}, {0xA8}, {0xB9}, {0xCA},   {0xAB}, {0xAC}, {0xB0}, {0xC1},   {0xA2}, {0xA3}, {0xB4}, {0xC5},   
					{0xA6}, {0xA7}, {0xB8}, {0xC9},   {0xAA}, {0xAB}, {0xBC}, {0xC0},   {0xA1}, {0xA2}, {0xB3}, {0xC4},   {0xA5}, {0xA6}, {0xB7}, {0xC8},   
				};
				RGBA result_arr  [Y*8*2][X*8]; memset(result_arr, SENTINEL, sizeof(result_arr));
				RGBA expected_arr[Y*8][X*8] = {{0}};
				for (int i = 0; i < Y/SF_Y; ++i) {
					for (int j = 0; j < X/SF_X; ++j) {
						int ci = (i * X/SF_X + j) * mcu_length;
						u8 a1 = coefficients_arr[ci + 0][0];
						u8 a2 = coefficients_arr[ci + 1][0];
						u8 b  = coefficients_arr[ci + 2][0];
						u8 c  = coefficients_arr[ci + 3][0];
						expected_arr[i*2*8+0][j*8].r = a1;
						expected_arr[i*2*8+8][j*8].r = a2;
						expected_arr[i*2*8+0][j*8].g = b;
						expected_arr[i*2*8+1][j*8].g = b;
						expected_arr[i*2*8+0][j*8].b = c;
						expected_arr[i*2*8+1][j*8].b = c;
					}
				}
				LaneInfo lane_infos_arr[mcu_length] = {
					{.c_id = 0, .sf_y=2, .sf_x=1, .start_in_mcu = 1, .amount_in_mcu = 2},
					{.c_id = 0, .sf_y=2, .sf_x=1},
					{.c_id = 1, .sf_y=1, .sf_x=1},
					{.c_id = 2, .sf_y=1, .sf_x=1},
				};
				
				
				Resource<MyOpenCL :: Buffer<float[64]>> coefficients(context, CL_MEM_READ_WRITE, Y/SF_Y * X/SF_X * mcu_length); if (!coefficients) { return false; }
				Resource<MyOpenCL :: Buffer<LaneInfo>>    lane_infos(context, CL_MEM_READ_WRITE, mcu_length                  ); if (!  lane_infos) { return false; }
				Resource<MyOpenCL :: Buffer<RGBA>>            result(context, CL_MEM_READ_WRITE, Y * X * 64 * 2              ); if (!      result) { return false; }
				
				if (!coefficients.write(queue, &coefficients_arr[0])) { return false; }
				if (!  lane_infos.write(queue, &  lane_infos_arr[0])) { return false; }
				if (!      result.write(queue, &   result_arr[0][0])) { return false; }
				
				if (!kernel.setArg_coefficients   (coefficients   )) { return false; }
				if (!kernel.setArg_image          (result         )) { return false; }
				if (!kernel.setArg_lane_infos     (lane_infos     )) { return false; }
				if (!kernel.setArg_max_sf         (max_sf         )) { return false; }
				if (!kernel.setArg_image_size     (image_size     )) { return false; }
				if (!kernel.setArg_mcu_length     (mcu_length     )) { return false; }
				if (!kernel.setArg_mcu_per_line   (mcu_per_line   )) { return false; }
				if (!kernel.setArg_component_count(component_count)) { return false; }

				if (!kernel(queue, work)) { return false; }
				
				if (!result.read(queue, &result_arr[0][0])) { return false; }
				//	for (int i = 0; i < Y*8; ++i) {
				//		for (int j = 0; j < X*8; ++j) {
				//			if (result_arr[i][j].r == 0xB2) { printf("R %d %d    ", i, j); }
				//			if (result_arr[i][j].g == 0xB2) { printf("G %d %d    ", i, j); }
				//			if (result_arr[i][j].b == 0xB2) { printf("B %d %d    ", i, j); }
				//			if (result_arr[i][j].a == 0xB2) { printf("A %d %d    ", i, j); }
				//		}
				//	} printf("!\n");
				for (int i = Y*8; i < Y*8*2; ++i) {
					for (int j = 0; j < X*8; ++j) {
						if (result_arr[i][j].r != SENTINEL            ) { Test :: getError() << "Error at " << i << ", " << j << " R2: Expected " << std::hex << (u16) SENTINEL             << " Got " << std::hex << (u16) result_arr[i][j].r << "!"; return false; }
						if (result_arr[i][j].g != SENTINEL            ) { Test :: getError() << "Error at " << i << ", " << j << " G2: Expected " << std::hex << (u16) SENTINEL             << " Got " << std::hex << (u16) result_arr[i][j].g << "!"; return false; }
						if (result_arr[i][j].b != SENTINEL            ) { Test :: getError() << "Error at " << i << ", " << j << " B2: Expected " << std::hex << (u16) SENTINEL             << " Got " << std::hex << (u16) result_arr[i][j].b << "!"; return false; }
						if (result_arr[i][j].a != SENTINEL            ) { Test :: getError() << "Error at " << i << ", " << j << " A2: Expected " << std::hex << (u16) SENTINEL             << " Got " << std::hex << (u16) result_arr[i][j].a << "!"; return false; }
					}
				}
				for (int i = 0; i < Y*8; ++i) {
					for (int j = 0; j < X*8; ++j) {
						if (result_arr[i][j].r != expected_arr[i][j].r) { Test :: getError() << "Error at " << i << ", " << j << " R:  Expected " << std::hex << (u16) expected_arr[i][j].r << " Got " << std::hex << (u16) result_arr[i][j].r << "!"; return false; }
						if (result_arr[i][j].g != expected_arr[i][j].g) { Test :: getError() << "Error at " << i << ", " << j << " G:  Expected " << std::hex << (u16) expected_arr[i][j].g << " Got " << std::hex << (u16) result_arr[i][j].g << "!"; return false; }
						if (result_arr[i][j].b != expected_arr[i][j].b) { Test :: getError() << "Error at " << i << ", " << j << " B:  Expected " << std::hex << (u16) expected_arr[i][j].b << " Got " << std::hex << (u16) result_arr[i][j].b << "!"; return false; }
						if (result_arr[i][j].a != SENTINEL            ) { Test :: getError() << "Error at " << i << ", " << j << " A:  Expected " << std::hex << (u16) SENTINEL             << " Got " << std::hex << (u16) result_arr[i][j].a << "!"; return false; }
					}
				}
				return true;
			}
		};
		struct Test_initializeBufferU32 : KernelsTest {
			fun char const* getDescription() { return "Test initializeBufferU32"; }
			fun bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.initializeBufferU32, program); if (!kernel) { return false; }
				
				size_t amount[1] = {1024};
				uint32_t value1 = 42;
				
				Resource<MyOpenCL :: Buffer<uint32_t>> device_buffer(context, CL_MEM_READ_WRITE, amount[0]); if (!device_buffer) { return false; }
				
				if (!kernel.setArg(device_buffer.buffer)) { return false; }
				if (!kernel.setArg(value1, 1)) { return false; }
				if (!kernel(queue, amount)) { return false; }
				
				uint32_t value2 = 33;
				if (!kernel.setArg(value2, 1)) { return false; }
				size_t offset2[1] = {1};
				size_t amount2[1] = {2};
				if (!kernel(queue, amount2, offset2)) { return false; }
				
				uint32_t my_buffer[10];
				
				if (!device_buffer.read(queue, my_buffer, 10)) { return false; }
				if (my_buffer[0] != value1) { std :: cerr << "Buffer wrong at 0: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[1] != value2) { std :: cerr << "Buffer wrong at 1: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[2] != value2) { std :: cerr << "Buffer wrong at 2: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[3] != value1) { std :: cerr << "Buffer wrong at 3: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[4] != value1) { std :: cerr << "Buffer wrong at 4: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[5] != value1) { std :: cerr << "Buffer wrong at 5: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[6] != value1) { std :: cerr << "Buffer wrong at 6: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[7] != value1) { std :: cerr << "Buffer wrong at 7: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[8] != value1) { std :: cerr << "Buffer wrong at 8: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[9] != value1) { std :: cerr << "Buffer wrong at 9: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				
				return true;
			}
		};
		
		Test_decodeHuffman1      test_decodeHuffman1     ;
		Test_decodeRaise         test_decodeRaise        ;
		Test_decodeLower         test_decodeLower        ;
		Test_positionsToIndexes  test_positionsToIndexes ;
		Test_decodeHuffman2      test_decodeHuffman2     ;
		Test_prepareMCUs         test_prepareMCUs        ;
		//	PrefixSumTest{name, mcu_length, half_size, lane_infos, coefficients, expected, },
		PrefixSumTest<1> test_prefixSum1_1_15 = {"Test prefixSum1 1 15", 1, 2, std::vector{LaneInfo{1}}, 
			std::vector<i32>{19, 29, 23, 33, 11, 11, 11, 30, 12, 26, 31, 11, 12, 21, 29}, 
			std::vector<i32>{19, 29, 23, 62, 11, 11, 11, 41, 12, 26, 31, 37, 12, 21, 29}
		};
		PrefixSumTest<1> test_prefixSum1_1_16 = {"Test prefixSum1 1 16", 1, 2, std::vector{LaneInfo{1}}, 
			std::vector<i32>{28, 22, 11, 24, 26, 26, 11, 33, 26, 30, 21, 12, 24, 32, 24, 18}, 
			std::vector<i32>{28, 22, 11, 46, 26, 26, 11, 59, 26, 30, 21, 42, 24, 32, 24, 50}
		};
		PrefixSumTest<1> test_prefixSum1_1_17 = {"Test prefixSum1 1 17", 1, 2, std::vector{LaneInfo{1}}, 
			std::vector<i32>{27, 26, 21, 23, 27, 30, 21, 24, 32, 21, 27, 15, 15, 14, 18, 32, 13}, 
			std::vector<i32>{27, 26, 21, 49, 27, 30, 21, 54, 32, 21, 27, 36, 15, 14, 18, 46, 13}
		};
		PrefixSumTest<1> test_prefixSum1_1_18 = {"Test prefixSum1 1 18", 1, 2, std::vector{LaneInfo{1}}, 
			std::vector<i32>{31, 21, 14, 26, 10, 19, 28, 22, 10, 24, 30, 32, 28, 22, 25, 25, 26, 29}, 
			std::vector<i32>{31, 21, 14, 47, 10, 19, 28, 41, 10, 24, 30, 56, 28, 22, 25, 47, 26, 29}
		};

		PrefixSumTest<1> test_prefixSum1_4 = {"Test prefixSum1 4", 4, 1, std::vector{LaneInfo{1}, LaneInfo{2}, LaneInfo{2}, LaneInfo{3}, }, 
			//	MCU = ABBC
			//	NCU = (A, B, BB, C)
			// NCU1 + NCU2 = (A1+A2, BB1+B2, BB1+BB2, C1+C2)
			std::vector<i32>{25,23,31,23, 31,28,27,27, 10,31,25,25, 18,27,28,29, 29,30,33,33},
			std::vector<i32>{25,23,31,23, 56,59,58,50, 10,31,25,25, 28,52,53,54, 29,30,33,33}
		};
		
		Test_uninterleave_upsample test_uninterleave_upsample;
		Test_initializeBufferU32 test_initializeBufferU32;
	}
}


#endif