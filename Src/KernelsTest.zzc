#ifdef TESTING
#include "./Util.zzh"
#pragma region zzc hdr_decl
	#include <cstdint>
	#include "./Test.zzh"
	#include "./kernels.cl.tmp.zzh"
#pragma endregion zzc
#pragma region zzc src_decl
	#include <iostream>
	#include <vector>
	#include "./MyOpenCL.zzh"
	#include "./Huffman.zzh"
	#include "./Context.zzh"
#pragma endregion zzc


#define PRINT_ARRAY_10(arr) "["\
	<< ((arr)[0]) << ", " \
	<< ((arr)[1]) << ", " \
	<< ((arr)[2]) << ", " \
	<< ((arr)[3]) << ", " \
	<< ((arr)[4]) << ", " \
	<< ((arr)[5]) << ", " \
	<< ((arr)[6]) << ", " \
	<< ((arr)[7]) << ", " \
	<< ((arr)[8]) << ", " \
	<< ((arr)[9]) << ", " \
<< "]"

#define PRINT_X_MATRIX(mat, h, w) {                         \
    for (int i = 0; i < (w); ++i) { printf(" %2d", i); }    \
    printf("\n");                                           \
    for (int i = 0; i < (h); ++i) {                         \
        for (int j = 0; j < (w); ++j) {                     \
            u32 v = (mat)[i][j];                            \
            if (v == x) { printf("  x"); }                 \
            else        { printf(" %2u", v); }              \
        }                                                   \
        printf("\n");                                       \
    }                                                       \
}

namespace BJpeg {
	namespace {
		Kernels kernels_var;
		
		template <typename T>
		struct Arr64 { 
			T arr[8][8]; 
			fun inline T& operator [](int i) { return self.arr[0][i]; }
			struct Index2D {int i, j;};
			fun inline T& operator [](Index2D index) { return self.arr[index.i][index.j]; }
		};
		
		fun std :: vector<Arr64<FI>> inflateTo64Coefficients(std :: vector<i32> dc_coefficients) {
			std :: vector<Arr64<FI>> result; result.resize(dc_coefficients.size());
			int index = 0;
			for (int index = 0; index < dc_coefficients.size(); ++index) {
				result[index][0].i = dc_coefficients[index];
				for (int i = 1; i < 64; ++i) {
					result[index][i].i = i;
					//	or any random value (but consistent between calls (we want that coefficients and expected have same ACs (in prefixSum test)))
				}
			}
			return result;
		}
		
		struct KernelsTest : Test {
			fun virtual bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) = 0;
			fun virtual bool test() {
				cl_device_id device_id;
				if (!MyOpenCL :: getDeviceId(device_id)) { return false; }
				
				Resource<MyOpenCL :: Context> context(device_id);               if (!context) { return false; }
				Resource<MyOpenCL :: Queue>   queue(device_id, context);        if (!queue  ) { return false; }
				Resource<MyOpenCL :: Program> program(device_id, context, BJpeg::kernels); if (!program) { return false; }
				
				return self.kernelTest(context, queue, program);
			}
		};
		
		struct BufferSetter {
			MyOpenCL :: Kernel<1> kernel;
			fun bool init(MyOpenCL :: Program program) { return self.kernel.init(program, "initializeBufferU32"); }
			fun void finish() noexcept { self.kernel.finish(); }
			fun bool operator ()(MyOpenCL :: Queue queue, MyOpenCL :: Buffer<u32> buffer, u32 value) {
				self.kernel.resetArgs();
				if (!self.kernel.setArg(buffer)) { return false; }
				if (!self.kernel.setArg(value)) { return false; }
				
				if (!self.kernel.call(queue, &buffer.length)) { return false; }
				return true;
			}
		};
		struct Test_decodeHuffman1 : KernelsTest {
			fun char const* getDescription() { return "Test decodeHuffman1"; }
			fun bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.decodeHuffman1, program);
				if (!kernel) { return false; }
				
				constexpr u32 const B2 = 14;
				constexpr u32 const lane_width = 128;
				constexpr u8 const lanes_count = 3;
				constexpr u8 const depth = 5;
				constexpr u8  const prev_size_pow = 0;
				u32 const x = ~(u32)0;
				
				HuffmanTree trees_arr[2][4] = {
					{
						{.nodes={{1, 4}, {2, 3}, {0, 3}, {0, 6}, {5, 8}, {6, 7}, {0, 7}, {0, 4}, {9, 10}, {0, 5}, {11, 12}, {0, 2}, {1, 0}}},
						{.nodes={{1, 2}, {0, 2}, {3, 4}, {0, 5}, {5, 6}, {0, 4}, {7, 8}, {0, 3}, {1, 0}}},
					},
					{
						{.nodes={{1, 14}, {2, 5}, {3, 4}, {0, 213}, {0, 149}, {6, 9}, {7, 8}, {0, 0}, {0, 197}, {10, 11}, {0, 20}, {12, 13}, {0, 5}, {0, 85}, {15, 34}, {16, 23}, {17, 20}, {18, 19}, {0, 212}, {0, 164}, {21, 22}, {0, 133}, {0, 147}, {24, 27}, {25, 26}, {0, 69}, {0, 228}, {28, 31}, {29, 30}, {0, 4}, {0, 148}, {32, 33}, {0, 53}, {0, 21}, {35, 58}, {36, 43}, {37, 40}, {38, 39}, {0, 99}, {0, 3}, {41, 42}, {0, 67}, {0, 131}, {44, 51}, {45, 48}, {46, 47}, {0, 84}, {0, 100}, {49, 50}, {0, 244}, {0, 180}, {52, 55}, {53, 54}, {0, 181}, {0, 196}, {56, 57}, {0, 229}, {0, 245}, {59, 74}, {60, 67}, {61, 64}, {62, 63}, {0, 227}, {0, 195}, {65, 66}, {0, 179}, {0, 68}, {68, 71}, {69, 70}, {0, 116}, {0, 243}, {72, 73}, {0, 115}, {0, 35}, {75, 82}, {76, 79}, {77, 78}, {0, 51}, {0, 37}, {80, 81}, {0, 211}, {0, 83}, {83, 90}, {84, 87}, {85, 86}, {0, 101}, {0, 52}, {88, 89}, {0, 117}, {0, 165}, {91, 94}, {92, 93}, {0, 240}, {0, 36}, {95, 98}, {96, 97}, {0, 163}, {0, 19}, {99, 100}, {0, 132}, {1, 0}}},
						{.nodes={{1, 12}, {2, 5}, {3, 4}, {0, 99}, {0, 116}, {6, 9}, {7, 8}, {0, 243}, {0, 240}, {10, 11}, {0, 244}, {0, 164}, {13, 28}, {14, 19}, {15, 16}, {0, 179}, {17, 18}, {0, 131}, {0, 67}, {20, 23}, {21, 22}, {0, 36}, {0, 35}, {24, 25}, {0, 100}, {26, 27}, {0, 115}, {0, 52}, {29, 44}, {30, 37}, {31, 34}, {32, 33}, {0, 212}, {0, 227}, {35, 36}, {0, 20}, {0, 132}, {38, 41}, {39, 40}, {0, 228}, {0, 0}, {42, 43}, {0, 196}, {0, 195}, {45, 52}, {46, 49}, {47, 48}, {0, 83}, {0, 4}, {50, 51}, {0, 51}, {0, 84}, {53, 58}, {54, 55}, {0, 148}, {56, 57}, {0, 211}, {0, 68}, {59, 62}, {60, 61}, {0, 3}, {0, 180}, {63, 66}, {64, 65}, {0, 163}, {0, 19}, {67, 68}, {0, 147}, {1, 0}}},
					},
				};
				u8 payload_arr[] = {237, 195, 199, 49, 126, 100, 208, 114, 185, 102, 90, 179, 218, 255, 255, 255};
				LaneInfo lane_infos_arr[lanes_count] = {{.dc_huf=0, .ac_huf=0}, {.dc_huf=0, .ac_huf=0}, {.dc_huf=1, .ac_huf=1}, };

				u32 initial[depth][lanes_count][lane_width] = {
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
				};
				u32 result  [depth][lanes_count][lane_width] = {{{0}}};
				u8 lane_indexes_arr[2] = {0, 2};
				
				Resource<MyOpenCL :: Buffer<u8>> payload(context, CL_MEM_READ_ONLY, sizeof(payload_arr));
				if (!payload) { return false; }
				if (!payload.write(queue, payload_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<HuffmanTree[4]>> trees(context, CL_MEM_READ_ONLY, 2);
				if (!trees) { return false; }
				if (!trees.write(queue, trees_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<LaneInfo>> lane_infos(context, CL_MEM_READ_ONLY, lanes_count);
				if (!lane_infos) { return false; }
				if (!lane_infos.write(queue, lane_infos_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<u32>> lanes(context, CL_MEM_READ_WRITE, depth * lanes_count * lane_width);
				if (!lanes) { return false; }
				if (!lanes.write(queue, &initial[0][0][0])) { return false; }
				Resource<MyOpenCL :: Buffer<u8>> lane_indexes(context, CL_MEM_READ_ONLY, 2);
				if (!lane_indexes) { return false; }
				if (!lane_indexes.write(queue, &lane_indexes_arr[0])) { return false; }
				
				if (!kernel.setArg_payload     (payload     )) { return false; }
				if (!kernel.setArg_B2          (B2          )) { return false; }
				if (!kernel.setArg_trees       (trees       )) { return false; }
				if (!kernel.setArg_lane_infos  (lane_infos  )) { return false; }
				if (!kernel.setArg_lanes       (lanes       )) { return false; }
				if (!kernel.setArg_lane_width  (lane_width  )) { return false; }
				if (!kernel.setArg_lane_indexes(lane_indexes)) { return false; }
				
				size_t global_work[2] = { 2, 8*B2 };
				if (!kernel.call(queue, global_work)) { return false; }
				
				if (!lanes.read(queue, &result[0][0][0])) { return false; }
				//	PRINT_X_MATRIX(result[0], lanes_count, lane_width);
				if (result[0][0][0] != 54) {
					Test :: getError() << "[0][0][0]: e=" << 54 << " v=" << result[0][0][0] << std :: endl;
					return false;
				}
				if (result[0][2][54] != 51) {
					Test :: getError() << "[0][2][54]: e=" << 51 << " v=" << result[0][2][54] << std :: endl;
					return false;
				}
				if (result[0][0][54 + 51] != x) {
					Test :: getError() << "[0][0][54 + 51]: e=x=" << x << " v=" << result[0][0][54 + 51] << std :: endl;
					return false;
				}
				
				return true;
			}
		};
		struct Test_decodeRaise : KernelsTest {
			fun char const* getDescription() { return "Test decodeRaise"; }
			fun bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.decodeRaise, program);
				if (!kernel) { return false; }
				
				constexpr u32 const lane_width = 64;
				constexpr u8 const lanes_count = 4;
				constexpr u8 const depth = 5;
				constexpr u8  const prev_size_pow = 0;
				u32 const x = ~(u32)0;
				u32 initial[depth][lanes_count][lane_width] = {
					{
						{3,2,1,4,3,2,1,x,4,3,2,1,4,3,2,1,3,2,1,2,1,3,2,1,x,4,3,2,1,1,4,3,2,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{3,2,1,4,3,2,1,x,4,3,2,1,4,3,2,1,3,2,1,2,1,3,2,1,x,4,3,2,1,1,4,3,2,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{3,2,1,4,3,2,1,5,4,3,2,1,4,3,2,1,3,2,1,2,1,3,2,1,5,4,3,2,1,1,4,3,2,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{3,3,2,4,3,3,2,5,4,3,3,2,4,3,3,2,3,3,2,3,2,3,3,2,5,4,3,3,2,2,4,3,3,2,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
				};
				u32 result  [depth][lanes_count][lane_width] = {{{0}}};
				u32 expected[depth][lanes_count][lane_width] = {
					{
						{3,2,1,4,3,2,1,x,4,3,2,1,4,3,2,1,3,2,1,2,1,3,2,1,x,4,3,2,1,1,4,3,2,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{3,2,1,4,3,2,1,x,4,3,2,1,4,3,2,1,3,2,1,2,1,3,2,1,x,4,3,2,1,1,4,3,2,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{3,2,1,4,3,2,1,5,4,3,2,1,4,3,2,1,3,2,1,2,1,3,2,1,5,4,3,2,1,1,4,3,2,1,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{3,3,2,4,3,3,2,5,4,3,3,2,4,3,3,2,3,3,2,3,2,3,3,2,5,4,3,3,2,2,4,3,3,2,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{7,6,5,x,x,x,x,x,8,7,6,5,7,6,5,4,5,4,3,5,4,x,x,x,x,5,4,3,2,5,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{7,6,5,9,8,7,6,9,8,7,6,5,7,6,5,4,6,5,4,5,4,8,7,6,7,6,5,4,3,5,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
					{
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
						{x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,},
					},
				};
				
				Resource<MyOpenCL :: Buffer<u32>> lanes(context, CL_MEM_READ_WRITE, depth * lanes_count * lane_width);
				if (!lanes) { return false; }
				if (!lanes.write(queue, &initial[0][0][0])) { return false; }
				
				if (!kernel.setArg_lanes(lanes)) { return false; }
				if (!kernel.setArg_lane_width(lane_width)) { return false; }
				if (!kernel.setArg_lanes_count(lanes_count)) { return false; }
				if (!kernel.setArg_prev_size_pow(prev_size_pow)) { return false; }
				
				size_t global_work[2] = { 2, lane_width };
				if (!kernel.call(queue, global_work)) { return false; }
				
				if (!lanes.read(queue, &result[0][0][0])) { return false; }
				for (u32 d = 0; d < depth; ++d) {
					for (u32 l = 0; l < lanes_count; ++l) {
						for (u32 i = 0; i < lane_width; ++i) {
							if (result[d][l][i] != expected[d][l][i]) {
								Test :: getError() << "[" << d << "][" << l << "][" << i << "]: e=" << expected[d][l][i] << " v=" << result[d][l][i] << std :: endl;
								return false;
							}
						}
					}
				}
				
				return true;
			}
		};
		struct Test_decodeLower : KernelsTest {
			fun char const* getDescription() { return "Test decodeLower"; }
			fun bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.decodeLower, program);
				if (!kernel) { return false; }
				Resource<BufferSetter> set_buf(program);
				if (!set_buf) { return false; }
				
				constexpr u32 const lane_width = 64;
				constexpr u8 const lanes_count = 4;
				constexpr u8 const depth = 5;
				u32 const x = ~(u32)0;
				u32 initial[depth][lanes_count][lane_width] = {
					{
						//0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59                                                
						{ 3, 2, 1, 4, 3, 2, 1, x, 4, 3, 2, 1, 4, 3, 2, 1, 3, 2, 1, 2, 1, 3, 2, 1, x, 4, 3, 2, 1, 1, 4, 3, 2, 1, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ 3, 2, 1, 4, 3, 2, 1, x, 4, 3, 2, 1, 4, 3, 2, 1, 3, 2, 1, 2, 1, 3, 2, 1, x, 4, 3, 2, 1, 1, 4, 3, 2, 1, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ 3, 2, 1, 4, 3, 2, 1, 5, 4, 3, 2, 1, 4, 3, 2, 1, 3, 2, 1, 2, 1, 3, 2, 1, 5, 4, 3, 2, 1, 1, 4, 3, 2, 1, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ 3, 3, 2, 4, 3, 3, 2, 5, 4, 3, 3, 2, 4, 3, 3, 2, 3, 3, 2, 3, 2, 3, 3, 2, 5, 4, 3, 3, 2, 2, 4, 3, 3, 2, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
					},
					{
						{ 7, 6, 5, x, x, x, x, x, 8, 7, 6, 5, 7, 6, 5, 4, 5, 4, 3, 5, 4, x, x, x, x, 5, 4, 3, 2, 5, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ 7, 6, 5, 9, 8, 7, 6, 9, 8, 7, 6, 5, 7, 6, 5, 4, 6, 5, 4, 5, 4, 8, 7, 6, 7, 6, 5, 4, 3, 5, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
					},
					{
						{16,15,14, x, x, x, x, x,14,13,12,11,12,11,10, 9,13,12,11,12,11, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
					},
					{
						{29,28,27, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
					},
					{
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
						{ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,},
					},
				};
				u32 result  [lane_width + 8] = {0};
				u32 expected[lane_width] = { 0,x,x,1,x,x,x,2,x,x,x,x,3,x,x,x,4,x,x,5,x,6,x,x,7,x,x,x,x,8,9,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x, };
				
				Resource<MyOpenCL :: Buffer<u32>> positions(context, CL_MEM_READ_WRITE, lane_width + 8);
				if (!positions) { return false; }
				if (!set_buf(queue, positions, x)) { return false; }
				u32 zero = 0;
				if (!positions.write(queue, &zero, 1)) { return false; }
				Resource<MyOpenCL :: Buffer<u32>> lanes(context, CL_MEM_READ_WRITE, depth * lanes_count * lane_width);
				if (!lanes) { return false; }
				if (!lanes.write(queue, &initial[0][0][0])) { return false; }
				
				if (!kernel.setArg_positions  (positions)) { return false; }
				if (!kernel.setArg_lanes      (lanes)) { return false; }
				if (!kernel.setArg_lane_width (lane_width)) { return false; }
				if (!kernel.setArg_lanes_count(lanes_count)) { return false; }
				
				u8 size_pow;
				size_t global_work[1] = { lane_width };
				
				size_pow = 3;
				if (!kernel.setArg_size_pow(size_pow)) { return false; }
				if (!kernel.call(queue, global_work)) { return false; }
				size_pow = 2;
				if (!kernel.setArg_size_pow(size_pow)) { return false; }
				if (!kernel.call(queue, global_work)) { return false; }
				size_pow = 1;
				if (!kernel.setArg_size_pow(size_pow)) { return false; }
				if (!kernel.call(queue, global_work)) { return false; }
				size_pow = 0;
				if (!kernel.setArg_size_pow(size_pow)) { return false; }
				if (!kernel.call(queue, global_work)) { return false; }
				
				if (!positions.read(queue, result)) { return false; }
				for (u32 i = 0; i < 34; ++i) { //	hardcoded
					if (result[i] != expected[i]) {
						Test :: getError() << "[" << i << "]: e=" << expected[i] << " v=" << result[i] << std :: endl;
						return false;
					}
				}
				
				return true;
			}
		};
		struct Test_positionsToIndexes : KernelsTest {
			fun char const* getDescription() { return "Test positionsToIndexes"; }
			fun bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.positionsToIndexes, program);
				if (!kernel) { return false; }
				Resource<BufferSetter> set_buf(program);
				if (!set_buf) { return false; }
				
				constexpr u32 const lane_width = 64;
				constexpr u32 const unit_count = 10;
				constexpr u8 const lanes_count = 4;
				constexpr u8 const depth = 5;
				u32 const x = ~(u32)0;
				
				u32 initial[lane_width] = { 0,x,x,1,x,x,x,2,x,x,x,x,3,x,x,x,4,x,x,5,x,6,x,x,7,x,x,x,x,8,9,x,x,x,10,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x, };
				u32 result  [unit_count] = {0};
				u32 expected[unit_count] = {0, 3, 7, 12, 16, 19, 21, 24, 29, 30};
				
				Resource<MyOpenCL :: Buffer<u32>> positions(context, CL_MEM_READ_WRITE, lane_width + 8);
				if (!positions) { return false; }
				if (!positions.write(queue, initial, lane_width)) { return false; }
				Resource<MyOpenCL :: Buffer<u32>> indexes(context, CL_MEM_READ_WRITE, unit_count + 1);
				if (!indexes) { return false; }
				
				if (!kernel.setArg_positions (positions )) { return false; }
				if (!kernel.setArg_indexes   (indexes   )) { return false; }
				
				size_t global_work[1] = { lane_width };
				if (!kernel.call(queue, global_work)) { return false; }
				if (!indexes.read(queue, result)) { return false; }
				
				for (int i = 0; i < unit_count; ++i) {
					if (result[i] != expected[i]) {
						Test :: getError() << "[" << i << "]: e=" << expected[i] << " v=" << result[i] << std :: endl;
						return false;
					}
				}
				
				return true;
			}
		};
		struct Test_decodeHuffman2 : KernelsTest {
			fun char const* getDescription() { return "Test decodeHuffman2"; }
			fun bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.decodeHuffman2, program);
				if (!kernel) { return false; }
				
				constexpr u32 const B2 = 14;
				constexpr u32 const lane_width = 128;
				constexpr u8 const lanes_count = 2;
				constexpr u8 const unit_count = 2;
				constexpr u8 const depth = 5;
				u32 const x = ~(u32)0;
				
				HuffmanTree trees_arr[2][4] = {
					{
						{.nodes={{1, 4}, {2, 3}, {0, 3}, {0, 6}, {5, 8}, {6, 7}, {0, 7}, {0, 4}, {9, 10}, {0, 5}, {11, 12}, {0, 2}, {1, 0}}},
						{.nodes={{1, 2}, {0, 2}, {3, 4}, {0, 5}, {5, 6}, {0, 4}, {7, 8}, {0, 3}, {1, 0}}},
					},
					{
						{.nodes={{1, 14}, {2, 5}, {3, 4}, {0, 213}, {0, 149}, {6, 9}, {7, 8}, {0, 0}, {0, 197}, {10, 11}, {0, 20}, {12, 13}, {0, 5}, {0, 85}, {15, 34}, {16, 23}, {17, 20}, {18, 19}, {0, 212}, {0, 164}, {21, 22}, {0, 133}, {0, 147}, {24, 27}, {25, 26}, {0, 69}, {0, 228}, {28, 31}, {29, 30}, {0, 4}, {0, 148}, {32, 33}, {0, 53}, {0, 21}, {35, 58}, {36, 43}, {37, 40}, {38, 39}, {0, 99}, {0, 3}, {41, 42}, {0, 67}, {0, 131}, {44, 51}, {45, 48}, {46, 47}, {0, 84}, {0, 100}, {49, 50}, {0, 244}, {0, 180}, {52, 55}, {53, 54}, {0, 181}, {0, 196}, {56, 57}, {0, 229}, {0, 245}, {59, 74}, {60, 67}, {61, 64}, {62, 63}, {0, 227}, {0, 195}, {65, 66}, {0, 179}, {0, 68}, {68, 71}, {69, 70}, {0, 116}, {0, 243}, {72, 73}, {0, 115}, {0, 35}, {75, 82}, {76, 79}, {77, 78}, {0, 51}, {0, 37}, {80, 81}, {0, 211}, {0, 83}, {83, 90}, {84, 87}, {85, 86}, {0, 101}, {0, 52}, {88, 89}, {0, 117}, {0, 165}, {91, 94}, {92, 93}, {0, 240}, {0, 36}, {95, 98}, {96, 97}, {0, 163}, {0, 19}, {99, 100}, {0, 132}, {1, 0}}},
						{.nodes={{1, 12}, {2, 5}, {3, 4}, {0, 99}, {0, 116}, {6, 9}, {7, 8}, {0, 243}, {0, 240}, {10, 11}, {0, 244}, {0, 164}, {13, 28}, {14, 19}, {15, 16}, {0, 179}, {17, 18}, {0, 131}, {0, 67}, {20, 23}, {21, 22}, {0, 36}, {0, 35}, {24, 25}, {0, 100}, {26, 27}, {0, 115}, {0, 52}, {29, 44}, {30, 37}, {31, 34}, {32, 33}, {0, 212}, {0, 227}, {35, 36}, {0, 20}, {0, 132}, {38, 41}, {39, 40}, {0, 228}, {0, 0}, {42, 43}, {0, 196}, {0, 195}, {45, 52}, {46, 49}, {47, 48}, {0, 83}, {0, 4}, {50, 51}, {0, 51}, {0, 84}, {53, 58}, {54, 55}, {0, 148}, {56, 57}, {0, 211}, {0, 68}, {59, 62}, {60, 61}, {0, 3}, {0, 180}, {63, 66}, {64, 65}, {0, 163}, {0, 19}, {67, 68}, {0, 147}, {1, 0}}},
					},
				};
				u8 payload_arr[] = {237, 195, 199, 49, 126, 100, 208, 114, 185, 102, 90, 179, 218, 255, 255, 255};
				LaneInfo lane_infos_arr[lanes_count] = {{.dc_huf=0, .ac_huf=0}, {.dc_huf=1, .ac_huf=1}, };
				u32 indexes_arr[unit_count] = {0, 54};

				struct {
					u8 SSSS;
					uint16_t bits;
				} expected[unit_count][64] = {
					{{2, 0b11}, {5, 0b00011}, {3, 0b110}, {0,0}      , {4, 0b0010}, {0,0}      , {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {3, 0b011}, }, 
					{{2, 0b00}, {4, 0b0101} , {0,0}     , {4, 0b1100}, {0,0}      , {4, 0b1101}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}     , {3, 0b110}, },
				};
					//	1110-11 01110-00011 110001-110 0110-0010 11111100 110010-011 0100
					//	0-00 111001-0101 110010-1100 110010-1101 0101 10011-110 110101
					//	11111111111111111111111
				FI result_arr[unit_count][8][8];
				
				Resource<MyOpenCL :: Buffer<u8>> payload(context, CL_MEM_READ_ONLY, sizeof(payload_arr));
				if (!payload) { return false; }
				if (!payload.write(queue, payload_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<HuffmanTree[4]>> trees(context, CL_MEM_READ_ONLY, 2);
				if (!trees) { return false; }
				if (!trees.write(queue, trees_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<LaneInfo>> lane_infos(context, CL_MEM_READ_ONLY, lanes_count);
				if (!lane_infos) { return false; }
				if (!lane_infos.write(queue, lane_infos_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<u32>> indexes(context, CL_MEM_READ_ONLY, unit_count);
				if (!indexes) { return false; }
				if (!indexes.write(queue, indexes_arr)) { return false; }
				Resource<MyOpenCL :: Buffer<FI[8][8]>> result(context, CL_MEM_READ_WRITE, unit_count);
				if (!result) { return false; }
				
				if (!kernel.setArg_payload     (payload    )) { return false; }
				if (!kernel.setArg_trees       (trees      )) { return false; }
				if (!kernel.setArg_lane_infos  (lane_infos )) { return false; }
				if (!kernel.setArg_lane_width  (lane_width )) { return false; }
				if (!kernel.setArg_lanes_count (lanes_count)) { return false; }
				if (!kernel.setArg_indexes     (indexes    )) { return false; }
				if (!kernel.setArg_coefficients(result     )) { return false; }
				
				size_t global_work[1] = { unit_count };
				if (!kernel.call(queue, global_work)) { return false; }
				
				if (!result.read(queue, result_arr)) { return false; }
				for (int unit_id = 0; unit_id < unit_count; ++unit_id) {
					for (int i = 0; i < 64; ++i) {
						auto ex   = expected  [unit_id][i];
						int16_t r = result_arr[unit_id][0][i].i;
						if (ex.SSSS == 0) {
							if (r != 0) {
								Test :: getError() << "[" << unit_id << "][" << i << "]: 0 e=" << ex.SSSS << "|" << ex.bits << " v=" << r << "(" << std::hex << r << ")" << std :: endl;
								return false;
							}
						} else {
							int M = 1 << ex.SSSS;
							int m = M >> 1;
							int mask = M - 1;
							if (m <= r && r < M) {
								if (r & mask != ex.bits) {
									Test :: getError() << "[" << unit_id << "][" << i << "]: + e=" << (u16) ex.SSSS << "|" << std::hex << ex.bits << " v=" << r << "(" << std::hex << r << ")" << std :: endl;
									return false;
								}
							} else if (-M < r && r <= -m) {
								if ((r - 1) & mask != ex.bits) {
									Test :: getError() << "[" << unit_id << "][" << i << "]: - e=" << (u16) ex.SSSS << "|" << std::hex << ex.bits << " v=" << r << "(" << std::hex << r << ")" << std :: endl;
									return false;
								}
							} else {
								Test :: getError() << "[" << unit_id << "][" << i << "]: SSSS e=" << (u16) ex.SSSS << "|" << std::hex << ex.bits << " v=" << r << "(" << std::hex << r << ")" << std :: endl;
								return false;
							}
						}
					}
				}
				
				return true;
			}
		};
		struct Test_prepareMCUs : KernelsTest {
			fun char const* getDescription() { return "Test prepareMCUs"; }
			fun bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.prepareMCUs, program); if (!kernel) { return false; }
				
				//                                                               A  B  B  C
				auto coefficients_arr = inflateTo64Coefficients(std::vector<i32>{25,23,31,23, 31,28,27,27, 10,31,25,25, 18,27,28,29, 29,30,33,33});
				auto expected_arr     = inflateTo64Coefficients(std::vector<i32>{25,23,54,23, 31,28,55,27, 10,31,56,25, 18,27,55,29, 29,30,63,33});
				auto lane_infos_arr = std::vector{LaneInfo{.start_in_mcu = 1, .amount_in_mcu = 2}};
				
				u8 mcu_length = 4;
				size_t work[2] = {1, coefficients_arr.size() / mcu_length};
				
				Resource<MyOpenCL :: Buffer<FI[8][8]>> coefficients(context, CL_MEM_READ_WRITE, coefficients_arr.size()); if (!coefficients) { return false; }
				Resource<MyOpenCL :: Buffer<LaneInfo>>  lane_infos(context, CL_MEM_READ_WRITE,   lane_infos_arr.size()); if (!  lane_infos) { return false; }
				
				if (!coefficients.write(queue, &coefficients_arr[0].arr)) { return false; }
				if (!  lane_infos.write(queue, &  lane_infos_arr[0])) { return false; }
				
				if (!kernel.setArg_coefficients(coefficients)) { return false; }
				if (!kernel.setArg_lane_infos  (lane_infos  )) { return false; }
				if (!kernel.setArg_mcu_length  (mcu_length  )) { return false; }
				if (!kernel.call(queue, work)) { return false; }
				
				if (!coefficients.read(queue, &coefficients_arr[0].arr)) { return false; }
				for (int i = 0; i < coefficients_arr.size(); ++i) {
					for (int j = 0; j < 64; ++j) {
						if (coefficients_arr[i][j].i != expected_arr[i][j].i) {
							Test :: getError() << "Error at " << i << ", " << j << ": Expected " << expected_arr[i][j].i << " Got " << coefficients_arr[i][j].i;
							return false;
						}
					}
				}
				
				return true;
			}
		};
		template <int PrefixId> requires (PrefixId == 1 || PrefixId == 2) struct _PrefixSumKernel    {};
		template <            >                                           struct _PrefixSumKernel<1> { static inline auto kernel = kernels_var.prefixSum1; };
		template <            >                                           struct _PrefixSumKernel<2> { static inline auto kernel = kernels_var.prefixSum2; };
		template <int PrefixId> requires (PrefixId == 1 || PrefixId == 2) auto prefixSum = _PrefixSumKernel<PrefixId> :: kernel;
		template <int PrefixId>
		struct PrefixSumTest : KernelsTest {
			char const* name;
			u8 mcu_length;
			u32 half_size;
			std :: vector<LaneInfo> lane_infos;
			std :: vector<Arr64<FI>> coefficients;
			std :: vector<Arr64<FI>> expected;
			fun inline PrefixSumTest(
				char const* name,
				u8 mcu_length,
				u32 half_size,
				std :: vector<LaneInfo> lane_infos,
				std :: vector<i32> coefficients,
				std :: vector<i32> expected
			) :
				name(name),
				mcu_length(mcu_length),
				half_size(half_size),
				lane_infos(lane_infos),
				coefficients(inflateTo64Coefficients(coefficients)),
				expected(inflateTo64Coefficients(expected))
			{}
			
			fun char const* getDescription() { return self.name; }
			fun bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				#ifdef VSCODE_ONLY
					Resource<typename Kernels::prefixSum1> kernel.call(kernels_var.prefixSum1, program);
				#else
					Resource kernel(prefixSum<PrefixId>, program); if (!kernel) { return false; }
				#endif
				
				if (self.coefficients.size() != self.expected.size()) { return false; }
				if (self.lane_infos.size() != mcu_length) { return false; }
				if (self.coefficients.size() / 64 % mcu_length != 0) { return false; }
				size_t n = self.coefficients.size() / mcu_length;
				
				Resource<MyOpenCL :: Buffer<FI[8][8] >> coefficients(context, CL_MEM_READ_WRITE, self.coefficients.size()); if (!coefficients) { return false; }
				Resource<MyOpenCL :: Buffer<LaneInfo>> lane_infos  (context, CL_MEM_READ_WRITE, self.lane_infos  .size()); if (!lane_infos  ) { return false; }
				
				if (!coefficients.write(queue, &self.coefficients[0].arr)) { return false; }
				if (!lane_infos  .write(queue, &self.lane_infos  [0])) { return false; }
				
				if (!kernel.setArg_coefficients(coefficients)) { return false; }
				if (!kernel.setArg_lane_infos  (lane_infos  )) { return false; }
				if (!kernel.setArg_half_size   (half_size   )) { return false; }
				if (!kernel.setArg_mcu_length  (mcu_length  )) { return false; }
				
				size_t amount[1] = {n / (2 * half_size)};
				if (!kernel.call(queue, amount)) { return false; }
				
				if (!coefficients.read(queue, &self.coefficients[0].arr)) { return false; }
				for (int i = 0; i < self.coefficients.size(); ++i) {
					for (int j = 0; j < 64; ++j) {
						if (self.coefficients[i][j].i != self.expected[i][j].i) {
							Test :: getError() << "Error at " << i << ", " << j << ": Expected " << self.expected[i][j].i << " Got " << self.coefficients[i][j].i;
							return false;
						}
					}
				}
				
				return true;
			}
		};
		struct Test_unzigzag_quantization_dct : KernelsTest {
			fun char const* getDescription() { return "Test unzigzag_quantization_dct"; }
			fun bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.unzigzag_quantization_dct, program);
				if (!kernel) { return false; }
				
				constexpr size_t unit_count = 1;
				constexpr size_t mcu_length = 1;
				size_t work[1] = {unit_count};
				
				FI coefficients_arr[unit_count][8][8] = {{
					{ {.i=1210}, {.i= -18}, {.i=  21}, {.i= -10}, {.i= -34}, {.i=  15}, {.i=  -9}, {.i=  26},  },
					{ {.i= -24}, {.i=  -8}, {.i=  -3}, {.i=  -5}, {.i=  -2}, {.i=  -9}, {.i=  23}, {.i=  -9},  },
					{ {.i= -11}, {.i=   6}, {.i=  14}, {.i=  10}, {.i=   4}, {.i=   9}, {.i=  -2}, {.i=   8},  },
					{ {.i= -15}, {.i= -18}, {.i=  11}, {.i= -14}, {.i= -19}, {.i=  14}, {.i=   3}, {.i=  -8},  },
					{ {.i=   1}, {.i= -18}, {.i=   1}, {.i=   0}, {.i=  -8}, {.i=  -3}, {.i=   8}, {.i= -11},  },
					{ {.i=  -3}, {.i= -20}, {.i=   7}, {.i=  -1}, {.i=  -3}, {.i=  18}, {.i=   8}, {.i=   4},  },
					{ {.i=  -2}, {.i=   2}, {.i=  -1}, {.i=  -4}, {.i=  18}, {.i=   8}, {.i=  15}, {.i=   1},  },
					{ {.i=  -7}, {.i=   1}, {.i=   4}, {.i=  -1}, {.i=  -7}, {.i=  -2}, {.i=  -6}, {.i=   0},  },
				}};
				FI     expected_arr[unit_count][8][8] = {{
					{ {.f=  140.0}, {.f=  144.0}, {.f=  147.0}, {.f=  140.0}, {.f=  140.0}, {.f=  155.0}, {.f=  179.0}, {.f=  175.0},  },
					{ {.f=  144.0}, {.f=  152.0}, {.f=  140.0}, {.f=  147.0}, {.f=  140.0}, {.f=  148.0}, {.f=  167.0}, {.f=  179.0},  },
					{ {.f=  152.0}, {.f=  155.0}, {.f=  136.0}, {.f=  167.0}, {.f=  163.0}, {.f=  162.0}, {.f=  152.0}, {.f=  172.0},  },
					{ {.f=  168.0}, {.f=  145.0}, {.f=  156.0}, {.f=  160.0}, {.f=  152.0}, {.f=  155.0}, {.f=  136.0}, {.f=  160.0},  },
					{ {.f=  162.0}, {.f=  148.0}, {.f=  156.0}, {.f=  148.0}, {.f=  140.0}, {.f=  136.0}, {.f=  147.0}, {.f=  162.0},  },
					{ {.f=  147.0}, {.f=  167.0}, {.f=  140.0}, {.f=  155.0}, {.f=  155.0}, {.f=  140.0}, {.f=  136.0}, {.f=  162.0},  },
					{ {.f=  136.0}, {.f=  156.0}, {.f=  123.0}, {.f=  167.0}, {.f=  162.0}, {.f=  144.0}, {.f=  140.0}, {.f=  147.0},  },
					{ {.f=  148.0}, {.f=  155.0}, {.f=  136.0}, {.f=  155.0}, {.f=  152.0}, {.f=  147.0}, {.f=  147.0}, {.f=  136.0},  },
				}};
				QuantizationTable Q_arr[4]; for (auto& q : flatten<u16>(Q_arr)) { q = 1; }
				LaneInfo lane_infos_arr[mcu_length] = {{.q_id = 0}};
				
				
				Resource<MyOpenCL :: Buffer<FI[8][8]>>           coefficients(context, CL_MEM_READ_WRITE, unit_count); if (!coefficients) { return false; }
				Resource<MyOpenCL :: Buffer<LaneInfo>>             lane_infos(context, CL_MEM_READ_WRITE, mcu_length); if (!  lane_infos) { return false; }
				Resource<MyOpenCL :: Buffer<QuantizationTable>>        qtable(context, CL_MEM_READ_ONLY , 4         ); if (!  qtable    ) { return false; }
				
				if (!coefficients.write(queue, coefficients_arr)) { return false; }
				if (!  lane_infos.write(queue,   lane_infos_arr)) { return false; }
				if (!      qtable.write(queue,            Q_arr)) { return false; }
				
				if (!kernel.setArg_coefficients      (coefficients)) { return false; }
				if (!kernel.setArg_lane_infos        (  lane_infos)) { return false; }
				if (!kernel.setArg_quantization_table(      qtable)) { return false; }
				if (!kernel.setArg_mcu_length        (  mcu_length)) { return false; }
				
				if (!kernel.call(queue, work)) { return false; }
				
				if (!coefficients.read(queue, coefficients_arr)) { return false; }
				for (int i = 0; i < 8; ++i) {
					for (int j = 0; j < 8; ++j) {
						float d = coefficients_arr[0][i][j].f - expected_arr[0][i][j].f;
						if (std :: abs(coefficients_arr[0][i][j].f - expected_arr[0][i][j].f) > 1) {
							Test :: getError() << "Error at dct [" << i << "][" << j << "]: Expected " << expected_arr[0][i][j].f << "   Got " << coefficients_arr[0][i][j].f << std :: endl;
							return false;
						}
						//	printf("%6.1f  ", coefficients_arr[0][i][j].f);
						//	printf("%4d  ", coefficients_arr[0][i][j].i);
					}
					//	printf("\n");
				}
				
				return true;
			}
		};
		struct Test_uninterleave_upsample : KernelsTest {
			fun char const* getDescription() { return "Test uninterleave_upsample"; }
			fun bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				return true
					&& self.kernelTestVertical  (context, queue, program)
					&& self.kernelTestHorizontal(context, queue, program)
					&& self.kernelTestBoth      (context, queue, program)
				;
			}
			fun bool kernelTestVertical(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.uninterleave_upsample, program); if (!kernel) { return false; }
				
				constexpr u8 mcu_length = 4;
				constexpr u8 Y = 6;
				constexpr u8 X = 4;
				constexpr u8 SF_Y = 2;
				constexpr u8 SF_X = 1;
				constexpr u8x2 max_sf = {SF_X, SF_Y};
				constexpr u32x2 image_size = {X*8, Y*8};
				constexpr u32 mcu_per_line = X/SF_X;
				constexpr u8 component_count = 3;
				constexpr float SENTINEL = (float) 0xDD;
				static_assert(Y % SF_Y == 0);
				static_assert(X % SF_X == 0);
				size_t work[2] = {Y/SF_Y, X/SF_X};
				//	AABC
				//	6x4 units (40x32)
				//	A1 B c   A1 B c
				//	A2 B c   A2 B c
				FI coefficients_arr[Y/SF_Y * X/SF_X * mcu_length][8][8] = {
					{{{.f=0xA0}}}, {{{.f=0xA1}}}, {{{.f=0xB2}}}, {{{.f=0xC3}}},   {{{.f=0xA4}}}, {{{.f=0xA5}}}, {{{.f=0xB6}}}, {{{.f=0xC7}}},   {{{.f=0xA8}}}, {{{.f=0xA9}}}, {{{.f=0xBA}}}, {{{.f=0xCB}}},   {{{.f=0xAC}}}, {{{.f=0xA0}}}, {{{.f=0xB1}}}, {{{.f=0xC2}}},   
					{{{.f=0xA3}}}, {{{.f=0xA4}}}, {{{.f=0xB5}}}, {{{.f=0xC6}}},   {{{.f=0xA7}}}, {{{.f=0xA8}}}, {{{.f=0xB9}}}, {{{.f=0xCA}}},   {{{.f=0xAB}}}, {{{.f=0xAC}}}, {{{.f=0xB0}}}, {{{.f=0xC1}}},   {{{.f=0xA2}}}, {{{.f=0xA3}}}, {{{.f=0xB4}}}, {{{.f=0xC5}}},   
					{{{.f=0xA6}}}, {{{.f=0xA7}}}, {{{.f=0xB8}}}, {{{.f=0xC9}}},   {{{.f=0xAA}}}, {{{.f=0xAB}}}, {{{.f=0xBC}}}, {{{.f=0xC0}}},   {{{.f=0xA1}}}, {{{.f=0xA2}}}, {{{.f=0xB3}}}, {{{.f=0xC4}}},   {{{.f=0xA5}}}, {{{.f=0xA6}}}, {{{.f=0xB7}}}, {{{.f=0xC8}}},   
				};
				RGBAF result_arr  [Y*8*2][X*8]; for (auto& x : flatten<RGBAF>(result_arr)) { x.r = x.g = x.b = x.a = SENTINEL; }
				RGBAF expected_arr[Y*8][X*8] = {{0}};
				for (int i = 0; i < Y/SF_Y; ++i) {
					for (int j = 0; j < X/SF_X; ++j) {
						int ci = (i * X/SF_X + j) * mcu_length;
						float a1 = coefficients_arr[ci + 0][0][0].f;
						float a2 = coefficients_arr[ci + 1][0][0].f;
						float b  = coefficients_arr[ci + 2][0][0].f;
						float c  = coefficients_arr[ci + 3][0][0].f;
						expected_arr[i*8*SF_Y+0][j*8*SF_X].r = a1;
						expected_arr[i*8*SF_Y+8][j*8*SF_X].r = a2;
						expected_arr[i*8*SF_Y+0][j*8*SF_X].g = b;
						expected_arr[i*8*SF_Y+1][j*8*SF_X].g = b;
						expected_arr[i*8*SF_Y+0][j*8*SF_X].b = c;
						expected_arr[i*8*SF_Y+1][j*8*SF_X].b = c;
					}
				}
				LaneInfo lane_infos_arr[mcu_length] = {
					{.c_id = 0, .sf_y=2, .sf_x=1, .start_in_mcu = 1, .amount_in_mcu = 2},
					{.c_id = 0, .sf_y=2, .sf_x=1},
					{.c_id = 1, .sf_y=1, .sf_x=1},
					{.c_id = 2, .sf_y=1, .sf_x=1},
				};
				
				Resource<MyOpenCL :: Buffer<FI[8][8]>>  coefficients(context, CL_MEM_READ_WRITE, Y/SF_Y * X/SF_X * mcu_length); if (!coefficients) { return false; }
				Resource<MyOpenCL :: Buffer<LaneInfo>>    lane_infos(context, CL_MEM_READ_WRITE, mcu_length                  ); if (!  lane_infos) { return false; }
				Resource<MyOpenCL :: Buffer<RGBAF>>           result(context, CL_MEM_READ_WRITE, Y * X * 64 * 2              ); if (!      result) { return false; }
				
				if (!coefficients.write(queue, &coefficients_arr[0])) { return false; }
				if (!  lane_infos.write(queue, &  lane_infos_arr[0])) { return false; }
				if (!      result.write(queue, &   result_arr[0][0])) { return false; }
				
				if (!kernel.setArg_coefficients   (coefficients   )) { return false; }
				if (!kernel.setArg_image_temp     (result         )) { return false; }
				if (!kernel.setArg_lane_infos     (lane_infos     )) { return false; }
				if (!kernel.setArg_max_sf         (max_sf         )) { return false; }
				if (!kernel.setArg_image_size     (image_size     )) { return false; }
				if (!kernel.setArg_mcu_length     (mcu_length     )) { return false; }
				if (!kernel.setArg_mcu_per_line   (mcu_per_line   )) { return false; }
				if (!kernel.setArg_component_count(component_count)) { return false; }

				if (!kernel.call(queue, work)) { return false; }
				
				if (!result.read(queue, &result_arr[0][0])) { return false; }
				for (int i = Y*8; i < Y*8*2; ++i) {
					for (int j = 0; j < X*8; ++j) {
						if (result_arr[i][j].r != SENTINEL            ) { Test :: getError() << "Error at V " << i << ", " << j << " R2: Expected " << std::hex << (u16) SENTINEL             << " Got " << std::hex << (u16) result_arr[i][j].r << "!"; return false; }
						if (result_arr[i][j].g != SENTINEL            ) { Test :: getError() << "Error at V " << i << ", " << j << " G2: Expected " << std::hex << (u16) SENTINEL             << " Got " << std::hex << (u16) result_arr[i][j].g << "!"; return false; }
						if (result_arr[i][j].b != SENTINEL            ) { Test :: getError() << "Error at V " << i << ", " << j << " B2: Expected " << std::hex << (u16) SENTINEL             << " Got " << std::hex << (u16) result_arr[i][j].b << "!"; return false; }
						if (result_arr[i][j].a != SENTINEL            ) { Test :: getError() << "Error at V " << i << ", " << j << " A2: Expected " << std::hex << (u16) SENTINEL             << " Got " << std::hex << (u16) result_arr[i][j].a << "!"; return false; }
					}
				}
				for (int i = 0; i < Y*8; ++i) {
					for (int j = 0; j < X*8; ++j) {
						if (result_arr[i][j].r != expected_arr[i][j].r) { Test :: getError() << "Error at V " << i << ", " << j << " R:  Expected " << std::hex << (u16) expected_arr[i][j].r << " Got " << std::hex << (u16) result_arr[i][j].r << "!"; return false; }
						if (result_arr[i][j].g != expected_arr[i][j].g) { Test :: getError() << "Error at V " << i << ", " << j << " G:  Expected " << std::hex << (u16) expected_arr[i][j].g << " Got " << std::hex << (u16) result_arr[i][j].g << "!"; return false; }
						if (result_arr[i][j].b != expected_arr[i][j].b) { Test :: getError() << "Error at V " << i << ", " << j << " B:  Expected " << std::hex << (u16) expected_arr[i][j].b << " Got " << std::hex << (u16) result_arr[i][j].b << "!"; return false; }
						//	if (result_arr[i][j].a != SENTINEL            ) { Test :: getError() << "Error at V " << i << ", " << j << " A:  Expected " << std::hex << (u16) SENTINEL             << " Got " << std::hex << (u16) result_arr[i][j].a << "!"; return false; }
					}
				}
				return true;
			}
			fun bool kernelTestHorizontal(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.uninterleave_upsample, program); if (!kernel) { return false; }
				
				
				constexpr u8 mcu_length = 4;
				constexpr u8 Y = 6;
				constexpr u8 X = 4;
				constexpr u8 SF_Y = 1;
				constexpr u8 SF_X = 2;
				constexpr u8x2 max_sf = {SF_X, SF_Y};
				constexpr u32x2 image_size = {X*8, Y*8};
				constexpr u32 mcu_per_line = X/SF_X;
				constexpr u8 component_count = 3;
				constexpr float SENTINEL = (float) 0xDD;
				static_assert(Y % SF_Y == 0);
				static_assert(X % SF_X == 0);
				size_t work[2] = {Y/SF_Y, X/SF_X};
				//	AABC
				//	6x4 units (40x32)
				//	A1 B c   A1 B c
				//	A2 B c   A2 B c
				FI coefficients_arr[Y/SF_Y * X/SF_X * mcu_length][8][8] = {
					{{{.f=0xA0}}}, {{{.f=0xA1}}}, {{{.f=0xB2}}}, {{{.f=0xC3}}},   {{{.f=0xA4}}}, {{{.f=0xA5}}}, {{{.f=0xB6}}}, {{{.f=0xC7}}},   
					{{{.f=0xA8}}}, {{{.f=0xA9}}}, {{{.f=0xBA}}}, {{{.f=0xCB}}},   {{{.f=0xAC}}}, {{{.f=0xA0}}}, {{{.f=0xB1}}}, {{{.f=0xC2}}},   
					{{{.f=0xA3}}}, {{{.f=0xA4}}}, {{{.f=0xB5}}}, {{{.f=0xC6}}},   {{{.f=0xA7}}}, {{{.f=0xA8}}}, {{{.f=0xB9}}}, {{{.f=0xCA}}},   
					{{{.f=0xAB}}}, {{{.f=0xAC}}}, {{{.f=0xB0}}}, {{{.f=0xC1}}},   {{{.f=0xA2}}}, {{{.f=0xA3}}}, {{{.f=0xB4}}}, {{{.f=0xC5}}},   
					{{{.f=0xA6}}}, {{{.f=0xA7}}}, {{{.f=0xB8}}}, {{{.f=0xC9}}},   {{{.f=0xAA}}}, {{{.f=0xAB}}}, {{{.f=0xBC}}}, {{{.f=0xC0}}},   
					{{{.f=0xA1}}}, {{{.f=0xA2}}}, {{{.f=0xB3}}}, {{{.f=0xC4}}},   {{{.f=0xA5}}}, {{{.f=0xA6}}}, {{{.f=0xB7}}}, {{{.f=0xC8}}},   
				};
				RGBAF result_arr  [Y*8*2][X*8]; for (auto& x : flatten<RGBAF>(result_arr)) { x.r = x.g = x.b = x.a = SENTINEL; }
				RGBAF expected_arr[Y*8][X*8] = {{0}};
				for (int i = 0; i < Y/SF_Y; ++i) {
					for (int j = 0; j < X/SF_X; ++j) {
						int ci = (i * X/SF_X + j) * mcu_length;
						float a1 = coefficients_arr[ci + 0][0][0].f;
						float a2 = coefficients_arr[ci + 1][0][0].f;
						float b  = coefficients_arr[ci + 2][0][0].f;
						float c  = coefficients_arr[ci + 3][0][0].f;
						expected_arr[i*8*SF_Y][j*8*SF_X+0].r = a1;
						expected_arr[i*8*SF_Y][j*8*SF_X+8].r = a2;
						expected_arr[i*8*SF_Y][j*8*SF_X+0].g = b;
						expected_arr[i*8*SF_Y][j*8*SF_X+1].g = b;
						expected_arr[i*8*SF_Y][j*8*SF_X+0].b = c;
						expected_arr[i*8*SF_Y][j*8*SF_X+1].b = c;
					}
				}
				LaneInfo lane_infos_arr[mcu_length] = {
					{.c_id = 0, .sf_y=1, .sf_x=2, .start_in_mcu = 1, .amount_in_mcu = 2},
					{.c_id = 0, .sf_y=1, .sf_x=2},
					{.c_id = 1, .sf_y=1, .sf_x=1},
					{.c_id = 2, .sf_y=1, .sf_x=1},
				};
				
				Resource<MyOpenCL :: Buffer<FI[8][8]>>  coefficients(context, CL_MEM_READ_WRITE, Y/SF_Y * X/SF_X * mcu_length); if (!coefficients) { return false; }
				Resource<MyOpenCL :: Buffer<LaneInfo>>    lane_infos(context, CL_MEM_READ_WRITE, mcu_length                  ); if (!  lane_infos) { return false; }
				Resource<MyOpenCL :: Buffer<RGBAF>>           result(context, CL_MEM_READ_WRITE, Y * X * 64 * 2              ); if (!      result) { return false; }
				
				if (!coefficients.write(queue, &coefficients_arr[0])) { return false; }
				if (!  lane_infos.write(queue, &  lane_infos_arr[0])) { return false; }
				if (!      result.write(queue, &   result_arr[0][0])) { return false; }
				
				if (!kernel.setArg_coefficients   (coefficients   )) { return false; }
				if (!kernel.setArg_image_temp     (result         )) { return false; }
				if (!kernel.setArg_lane_infos     (lane_infos     )) { return false; }
				if (!kernel.setArg_max_sf         (max_sf         )) { return false; }
				if (!kernel.setArg_image_size     (image_size     )) { return false; }
				if (!kernel.setArg_mcu_length     (mcu_length     )) { return false; }
				if (!kernel.setArg_mcu_per_line   (mcu_per_line   )) { return false; }
				if (!kernel.setArg_component_count(component_count)) { return false; }

				if (!kernel.call(queue, work)) { return false; }
				
				if (!result.read(queue, &result_arr[0][0])) { return false; }
				for (int i = Y*8; i < Y*8*2; ++i) {
					for (int j = 0; j < X*8; ++j) {
						if (result_arr[i][j].r != SENTINEL            ) { Test :: getError() << "Error at H " << i << ", " << j << " R2: Expected " << std::hex << (u16) SENTINEL             << " Got " << std::hex << (u16) result_arr[i][j].r << "!"; return false; }
						if (result_arr[i][j].g != SENTINEL            ) { Test :: getError() << "Error at H " << i << ", " << j << " G2: Expected " << std::hex << (u16) SENTINEL             << " Got " << std::hex << (u16) result_arr[i][j].g << "!"; return false; }
						if (result_arr[i][j].b != SENTINEL            ) { Test :: getError() << "Error at H " << i << ", " << j << " B2: Expected " << std::hex << (u16) SENTINEL             << " Got " << std::hex << (u16) result_arr[i][j].b << "!"; return false; }
						if (result_arr[i][j].a != SENTINEL            ) { Test :: getError() << "Error at H " << i << ", " << j << " A2: Expected " << std::hex << (u16) SENTINEL             << " Got " << std::hex << (u16) result_arr[i][j].a << "!"; return false; }
					}
				}
				for (int i = 0; i < Y*8; ++i) {
					for (int j = 0; j < X*8; ++j) {
						if (result_arr[i][j].r != expected_arr[i][j].r) { Test :: getError() << "Error at H " << i << ", " << j << " R:  Expected " << std::hex << (u16) expected_arr[i][j].r << " Got " << std::hex << (u16) result_arr[i][j].r << "!"; return false; }
						if (result_arr[i][j].g != expected_arr[i][j].g) { Test :: getError() << "Error at H " << i << ", " << j << " G:  Expected " << std::hex << (u16) expected_arr[i][j].g << " Got " << std::hex << (u16) result_arr[i][j].g << "!"; return false; }
						if (result_arr[i][j].b != expected_arr[i][j].b) { Test :: getError() << "Error at H " << i << ", " << j << " B:  Expected " << std::hex << (u16) expected_arr[i][j].b << " Got " << std::hex << (u16) result_arr[i][j].b << "!"; return false; }
						//	if (result_arr[i][j].a != SENTINEL            ) { Test :: getError() << "Error at H " << i << ", " << j << " A:  Expected " << std::hex << (u16) SENTINEL             << " Got " << std::hex << (u16) result_arr[i][j].a << "!"; return false; }
					}
				}
				return true;
			}
			fun bool kernelTestBoth(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				return true;
			}
		};
		struct Test_initializeBufferU32 : KernelsTest {
			fun char const* getDescription() { return "Test initializeBufferU32"; }
			fun bool kernelTest(MyOpenCL :: Context context, MyOpenCL :: Queue queue, MyOpenCL :: Program program) {
				Resource kernel(kernels_var.initializeBufferU32, program); if (!kernel) { return false; }
				
				size_t amount[1] = {1024};
				u32 value1 = 42;
				
				Resource<MyOpenCL :: Buffer<u32>> device_buffer(context, CL_MEM_READ_WRITE, amount[0]); if (!device_buffer) { return false; }
				
				if (!kernel.setArg(device_buffer.buffer)) { return false; }
				if (!kernel.setArg(value1, 1)) { return false; }
				if (!kernel.call(queue, amount)) { return false; }
				
				u32 value2 = 33;
				if (!kernel.setArg(value2, 1)) { return false; }
				size_t offset2[1] = {1};
				size_t amount2[1] = {2};
				if (!kernel.call(queue, amount2, offset2)) { return false; }
				
				u32 my_buffer[10];
				
				if (!device_buffer.read(queue, my_buffer, 10)) { return false; }
				if (my_buffer[0] != value1) { std :: cerr << "Buffer wrong at 0: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[1] != value2) { std :: cerr << "Buffer wrong at 1: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[2] != value2) { std :: cerr << "Buffer wrong at 2: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[3] != value1) { std :: cerr << "Buffer wrong at 3: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[4] != value1) { std :: cerr << "Buffer wrong at 4: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[5] != value1) { std :: cerr << "Buffer wrong at 5: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[6] != value1) { std :: cerr << "Buffer wrong at 6: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[7] != value1) { std :: cerr << "Buffer wrong at 7: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[8] != value1) { std :: cerr << "Buffer wrong at 8: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				if (my_buffer[9] != value1) { std :: cerr << "Buffer wrong at 9: " << PRINT_ARRAY_10(my_buffer) << std :: endl; return false; }
				
				return true;
			}
		};
		
		Test_decodeHuffman1      test_decodeHuffman1     ;
		Test_decodeRaise         test_decodeRaise        ;
		Test_decodeLower         test_decodeLower        ;
		Test_positionsToIndexes  test_positionsToIndexes ;
		Test_decodeHuffman2      test_decodeHuffman2     ;
		Test_prepareMCUs         test_prepareMCUs        ;
		//	PrefixSumTest{name, mcu_length, half_size, lane_infos, coefficients, expected, },
		PrefixSumTest<1> test_prefixSum1_1_15 = {"Test prefixSum1 1 15", 1, 2, std::vector{LaneInfo{1}}, 
			std::vector<i32>{19, 29, 23, 33, 11, 11, 11, 30, 12, 26, 31, 11, 12, 21, 29}, 
			std::vector<i32>{19, 29, 23, 62, 11, 11, 11, 41, 12, 26, 31, 37, 12, 21, 29}
		};
		PrefixSumTest<1> test_prefixSum1_1_16 = {"Test prefixSum1 1 16", 1, 2, std::vector{LaneInfo{1}}, 
			std::vector<i32>{28, 22, 11, 24, 26, 26, 11, 33, 26, 30, 21, 12, 24, 32, 24, 18}, 
			std::vector<i32>{28, 22, 11, 46, 26, 26, 11, 59, 26, 30, 21, 42, 24, 32, 24, 50}
		};
		PrefixSumTest<1> test_prefixSum1_1_17 = {"Test prefixSum1 1 17", 1, 2, std::vector{LaneInfo{1}}, 
			std::vector<i32>{27, 26, 21, 23, 27, 30, 21, 24, 32, 21, 27, 15, 15, 14, 18, 32, 13}, 
			std::vector<i32>{27, 26, 21, 49, 27, 30, 21, 54, 32, 21, 27, 36, 15, 14, 18, 46, 13}
		};
		PrefixSumTest<1> test_prefixSum1_1_18 = {"Test prefixSum1 1 18", 1, 2, std::vector{LaneInfo{1}}, 
			std::vector<i32>{31, 21, 14, 26, 10, 19, 28, 22, 10, 24, 30, 32, 28, 22, 25, 25, 26, 29}, 
			std::vector<i32>{31, 21, 14, 47, 10, 19, 28, 41, 10, 24, 30, 56, 28, 22, 25, 47, 26, 29}
		};

		PrefixSumTest<1> test_prefixSum1_4 = {"Test prefixSum1 4", 4, 1, std::vector{LaneInfo{1}, LaneInfo{2}, LaneInfo{2}, LaneInfo{3}, }, 
			//	MCU = ABBC
			//	NCU = (A, B, BB, C)
			// NCU1 + NCU2 = (A1+A2, BB1+B2, BB1+BB2, C1+C2)
			std::vector<i32>{25,23,31,23, 31,28,27,27, 10,31,25,25, 18,27,28,29, 29,30,33,33},
			std::vector<i32>{25,23,31,23, 56,59,58,50, 10,31,25,25, 28,52,53,54, 29,30,33,33}
		};
		
		Test_unzigzag_quantization_dct test_unzigzag_quantization_dct;
		Test_uninterleave_upsample test_uninterleave_upsample;
		Test_initializeBufferU32 test_initializeBufferU32;
	}
}


#endif