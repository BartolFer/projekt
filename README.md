# BJpeg  
projekt FER diplomski  
author: Bartol Hrg  

This is a simple C++ library for decoding and encoding JPEG images using GPU (implemented in OpenCL).  

(All relative paths in this README are relative to the root of the project (therefore, this is `./README.md`))  

Main export of this project is a static library `./Targets/Library/Static/Build/libBJpeg.so`,  
as well as the header files inside `./Targets/Library/Static/include/`.  

## Dependencies  
To compile and use this project, you will need the following:  
- OpenCL 3  
- Python 3.10+  
- Makefile  
- gcc - C++23 (it might be possible to use other compilers, but there are no instructions for other compilers)  

There is also `./Scripts/RgbDisplay/` which can read `.rgba` file (the result of the decode process) and show it on screen.  
If you want to compile and run `./Scripts/RgbDisplay/`, you will also need:  
- OpenGL  
  - glad  
  - glfw  

There is also a GUI application for easier running of the examples. For that, you will need:  
- Python tkinter module  

## Compile  
To compile, follow these steps:  
1. Configure paths in `./Scripts/SetupVars.py` (variables at the top of the file)  
2. Run script `./Scripts/Compile.py` (There is also `./Scripts/Clean.py` to remove everything generated by this command)  

## Usage  
To see example usage of the library, see `./Targets/Examples/Decode/` and `./Targets/Examples/Encode/`.  

Disclaimer ⚠️: there are some restrictions on the image this library can (currently) decode:  
- Image must not use hierarchical mode.  
- Image must use Baseline DCT.  
- Image must use Huffman encoding.  
- Image must not use restart intervals.  
- Image must not use DNL segment.  
(Image can be easily converted to meet these requirements using GIMP (3.0) by exporting to JPEG and tweaking some options)  

Detailed explanation of the API will be in later chapter [Detailed Usage](#detailed-usage).  



## Run Examples  
To run these examples, you can use GUI application `./Scripts/Runner.py`, or run programs individually from terminal.  

### `./Scripts/Runner.py`  
GUI application for running examples.  
Arguments:  
1. `path/to/config.json` - optional  

The GUI interface consists of rows of commands and the bottom row for some useful actions.  

The best way to use it is:  

0. Find an image which you want to decode/encode.  
1. If you've already run that image with this application, you can click `Load` and select previously saved configuration.  
2. Otherwise, you can click `Smart Default`, select that image, and select place to save configuration.  
3. Click `Smart Run`. This will:  
    1. decode image  
    2. open that result (using `./Scripts/RgbDisplay/`)  
    3. encode that result back into another `.jpg` file  
    4. open that result (by decoding and then using `./Scripts/RgbDisplay/`)  

GUI layout:  
- On the bottom:  
  - `Add`: adds command row.  
  - `Load`: configuration from a file.  
  - `Store`: store current configuration into a file.  
  - `Smart Default`: select an image, create default configuration for it and store it into a file.  
  - `Smart Run`: Explained above.  
- In each command row:  
  - `▶` button: run command  
  - text entries: executable file and its command arguments.  
    - Each entry includes buttons for selecting file and folder respectively.  
  - `+` button: add command argument.  
  - `X` button: terminate command.  

### `./Targets/Examples/Decode/Build/BJpegDecode.exe`  
Decode JPEG into RGBA.  
Arguments:  
1. `path/to/image.jpg`  
2. `path/to/ouput.rgba`  

#### `.rgba` file format  
This is binary file. First bytes are reserved for a single instance of the `MetaData` structure defined in `./Targets/Examples/Metadata.hpp`.  
Immediately after s array of pixels with 4 values R, G, B, A in packed format (RGBARGBARGBA...).  
Endianness is platform dependant (Therefore it is not portable).  

### `./Targets/Examples/Encode/Build/BJpegEncode.exe`  
Encode RGBA into JPEG.  
Arguments:  
1. `path/to/image.rgba`  
2. `path/to/Quatization table definitions.jpg`  
3. `path/to/output.jpg`  
4. reverse sampling factors of (Cb & Cr) (reverse sampling factor N means that image is downsampled by N)  
    - optional (default is `11`)  
    - can be a single number (`2` is same as `22`)  
    - can be 2 numbers `yx` (e.g. `21`)  
    - 1st number is reverse sampling factor in vertical direction  
    - 2nd number is reverse sampling factor in horizontal direction  

### `./Scripts/RgbDisplay/RgbDisplay.exe`  
Read RGBA and display it on screen.  
Arguments:  
1. `path/to/image.rgba`  

Note: requires OpenGL!  

### `./Scripts/JPG_to_JPGDEF.py`  
Simple script for extracting Quantization tables from JPEG image.  
Arguments:  
1. `path/to/image.jpg`  
2. `path/to/ouput.def.jpg`  

## Detailed Usage  
The API provides 2 main functions:  
```c++
BJpeg :: Decode :: image(
    BJpeg :: Decode :: Context& context,
    BJpeg :: Decode :: InputFileBuffer& file,
    BJpeg :: u32 index
) -> BJpeg :: u32;

BJpeg :: Encode :: image(
    MyOpenCL :: Buffer<BJpeg :: RGBA> image,
    BJpeg :: Encode :: CLContext cl,
    size_t height,
    size_t width,
    BJpeg :: QuantizationTable qtables[4],
    BJpeg :: SamplingFactor sampling_factors[MAX_COMPONENTS]
) -> ArrayWithLength<u8>;
```

### Decode image  
```c++
BJpeg :: Decode :: image(
    BJpeg :: Decode :: Context& context,
    BJpeg :: Decode :: InputFileBuffer& file,
    BJpeg :: u32 index
) -> BJpeg :: u32;
```
- `context`: caller is responsible for calling `init` & `finish` methods (see also [Resource](#resource) and [defer](#defer)).  
- `file`: JPG file. Caller is responsible for calling `init` & `finish` methods (see also [Resource](#resource) and [defer](#defer)).  
- `index`: should be 0, except if image doesn't (for some reason) start at the beginning of the file.  
- return: index after the last consumed byte if successful, 0 if failed.  
The result can be read into array using `context.cl.buffer.image.read(...)` methods.  
Width & height can be read from `context.size.x_mayor` and `context.size.y_mayor`.  
Caller is also responsible for calling `context.cl.buffer.image.finish()` (see [defer](#defer)).  

### Encode image  
```c++
BJpeg :: Encode :: image(
    MyOpenCL :: Buffer<BJpeg :: RGBA> image,
    BJpeg :: Encode :: CLContext cl,
    size_t height,
    size_t width,
    BJpeg :: QuantizationTable qtables[4],
    BJpeg :: SamplingFactor sampling_factors[MAX_COMPONENTS]
) -> ArrayWithLength<u8>;
```
- `image`: OpenCL buffer containing pixels in RGBA format (not to be confused with file format: this doesn't contain `MetaData`). Caller is responsible for calling `init` & `finish` methods (see also [Resource](#resource) and [defer](#defer)).  
- `cl`: Caller is responsible for calling `init` & `finish` methods (see also [Resource](#resource) and [defer](#defer)).  
- `height` & `width` of an image.  
- `qtables`: quantization tables.  
- `sampling_factors`: array of yx sampling factors (y comes 1st) (usually in the form `{{y, x}, {1, 1}, {1, 1}}`).  
- return: Contains members `.length` and `.array`. Can be checked using `operator bool` (like `if (result)` or `if (!result)`).  
If successful, user is responsible for calling `result.finish()` (see [defer](#defer)).  

### `Resource`  
Template that automatically calls `init` and `finish` methods.  
That would make it similar to standard C++ RAII.  
`Resource<A>` is a subclass of `A`, so it can be cast to it, and all members from `A` can be used.  
`init` is called during construction. There are 2 constructors: One has 1st argument of type `A`, and the other one uses default constructor. Other arguments are the same as for `init` method.  
```c++
Resource<A> :: Resource(A a, args_of_init...);
Resource<A> :: Resource(args_of_init...);
```
`finish` is called when the object goes out of scope.  

### `defer`  
Macro that defers execution of a block of code to the end of a function.  
Syntax is `defer { any code };`.  
```c++
void f() {
    defer { printf("This will be printed last"); };
    printf("This will be printed 1st");
}
```


